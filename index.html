<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Route Tracker - Dark</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; }
        #map { height: 100%; width: 100%; }
        /* Custom scrollbar for dark theme */
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #1f2937; } /* gray-800 */
        ::-webkit-scrollbar-thumb { background: #4b5563; border-radius: 4px; } /* gray-600 */
        ::-webkit-scrollbar-thumb:hover { background: #6b7280; } /* gray-500 */
        
        /* Style for disabled buttons */
        button:disabled {
            background-color: #4b5563; /* gray-600 */
            cursor: not-allowed;
            opacity: 0.7;
        }
        /* Styling for Google Places Autocomplete dropdown */
        .pac-container {
            background-color: #1f2937; /* gray-800 */
            border-radius: 0.5rem;
            border: 1px solid #4b5563; /* gray-600 */
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            z-index: 9999 !important; /* Ensure it's above modals */
        }
        .pac-item {
            padding: 0.5rem 1rem;
            cursor: pointer;
            color: #d1d5db; /* gray-300 */
            border-top: 1px solid #374151; /* gray-700 */
        }
        .pac-item:first-child {
            border-top: none;
        }
        .pac-item:hover {
            background-color: #374151; /* gray-700 */
        }
        .pac-item-query {
            color: #f9fafb; /* gray-50 */
            font-weight: 500;
        }
        .pac-matched {
            color: #60a5fa; /* blue-400 */
        }
        
        /* Spinner */
        .spinner {
            display: inline-block;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: #fff;
            width: 1rem;
            height: 1rem;
            animation: spin 1s ease-in-out infinite;
        }
        .large-spinner {
             width: 3rem;
             height: 3rem;
             border-width: 4px;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        .tab-btn.active {
            border-bottom-color: #4f46e5; /* indigo-600 */
            color: #e5e7eb; /* gray-200 */
        }

        @media print {
            body * {
                visibility: hidden;
            }
            #job-details-printable, #job-details-printable * {
                visibility: visible;
            }
            #job-details-printable {
                position: absolute;
                left: 0;
                top: 0;
                width: 100%;
                background-color: white;
                color: black;
            }
            #job-details-printable h3, #job-details-printable strong {
                color: black !important;
            }
            #job-details-printable button {
                display: none;
            }
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-200">

    <!-- Fullscreen Loader -->
    <div id="loading-overlay" class="fixed inset-0 bg-gray-900 flex items-center justify-center z-[10001]">
        <div class="text-center">
            <div class="spinner large-spinner mx-auto"></div>
            <p class="text-gray-400 mt-4">Connecting to Route Tracker...</p>
        </div>
    </div>

    <!-- Toast Container -->
    <div id="toast-container" class="fixed top-4 right-4 z-[10000]"></div>

    <!-- Auth Container -->
    <div id="auth-container" class="hidden flex items-center justify-center h-screen">
        <div class="w-full max-w-sm text-center">
             <h1 class="text-4xl font-bold text-white mb-2">Route Tracker</h1>
             <p class="text-gray-400 mb-8">Please sign in to continue</p>
             <button id="google-signin-btn" class="bg-white text-gray-800 font-bold py-3 px-6 rounded-lg shadow-md hover:bg-gray-200 flex items-center justify-center w-full">
                 <svg class="w-6 h-6 mr-3" viewBox="0 0 48 48"><path fill="#EA4335" d="M24 9.5c3.54 0 6.71 1.22 9.21 3.6l6.85-6.85C35.9 2.38 30.47 0 24 0 14.62 0 6.51 5.38 2.56 13.22l7.98 6.19C12.43 13.72 17.74 9.5 24 9.5z"></path><path fill="#4285F4" d="M46.98 24.55c0-1.57-.15-3.09-.38-4.55H24v9.02h12.94c-.58 2.96-2.26 5.48-4.78 7.18l7.73 6c4.51-4.18 7.09-10.36 7.09-17.65z"></path><path fill="#FBBC05" d="M10.53 28.59c-.48-1.45-.76-2.99-.76-4.59s.27-3.14.76-4.59l-7.98-6.19C.92 16.46 0 20.12 0 24c0 3.88.92 7.54 2.56 10.78l7.97-6.19z"></path><path fill="#34A853" d="M24 48c6.48 0 11.93-2.13 15.89-5.81l-7.73-6c-2.15 1.45-4.92 2.3-8.16 2.3-6.26 0-11.57-4.22-13.47-9.91l-7.98 6.19C6.51 42.62 14.62 48 24 48z"></path><path fill="none" d="M0 0h48v48H0z"></path></svg>
                 Sign in with Google
             </button>
        </div>
    </div>

    <!-- App Container -->
    <div id="app-container" class="hidden flex flex-col md:flex-row h-screen">
        <!-- Map View -->
        <div id="map-container" class="w-full md:w-2/3 h-1/2 md:h-full">
            <div id="map" class="rounded-lg shadow-md bg-gray-700 flex items-center justify-center">
                <p class="text-gray-400">Loading Map...</p>
            </div>
        </div>

        <!-- Sidebar -->
        <div class="w-full md:w-1/3 h-1/2 md:h-full flex flex-col bg-gray-800 p-4 space-y-4 overflow-y-auto">
            <div id="sidebar-content">
                <div class="flex items-center justify-between pb-2 border-b border-gray-700">
                    <h1 class="text-2xl font-bold text-white">Route Tracker</h1>
                    <div class="flex items-center space-x-4">
                        <button id="profile-btn" class="text-gray-400 hover:text-white">
                            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M16 7a4 4 0 11-8 0 4 4 0 018 0zM12 14a7 7 0 00-7 7h14a7 7 0 00-7-7z"></path></svg>
                        </button>
                        <button id="settings-btn" class="hidden text-gray-400 hover:text-white">
                            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path></svg>
                        </button>
                        <button id="logout-btn" class="text-sm text-red-400 hover:text-red-300">Logout</button>
                    </div>
                </div>
                
                <div id="user-info-panel" class="bg-gray-900 p-4 rounded-lg shadow-sm mt-4">
                     <h2 id="user-welcome" class="text-lg font-semibold text-gray-200 mb-2">Welcome!</h2>
                     <p class="text-sm text-gray-400">Your User ID: <span id="userId" class="font-mono break-all"></span></p>
                </div>

                <!-- Dispatcher UI -->
                <div id="dispatch-ui" class="hidden">
                    <div id="management-actions-panel" class="bg-gray-900 p-4 rounded-lg shadow-sm mt-4">
                        <h2 class="text-lg font-semibold text-gray-200 mb-2">Management Actions</h2>
                        <div id="dispatcher-actions" class="grid grid-cols-1 gap-2">
                            <button id="open-create-job-modal-btn" class="w-full px-4 py-2 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700">Create Job</button>
                        </div>
                    </div>
                    <div id="drivers-panel" class="bg-gray-900 p-4 rounded-lg shadow-sm mt-4">
                        <div class="flex justify-between items-center mb-2">
                            <h3 class="text-lg font-semibold text-gray-200">Drivers</h3>
                        </div>
                        <ul id="drivers-list" class="space-y-2"></ul>
                    </div>
                    <div id="job-dashboard-panel" class="bg-gray-900 p-4 rounded-lg shadow-sm mt-4">
                        <div class="flex border-b border-gray-700">
                            <button data-tab="current" class="tab-btn flex-1 py-2 text-center font-semibold text-gray-400 border-b-2 border-transparent hover:border-gray-500 hover:text-gray-300 active">Current</button>
                            <button data-tab="archive" class="tab-btn flex-1 py-2 text-center font-semibold text-gray-400 border-b-2 border-transparent hover:border-gray-500 hover:text-gray-300">Archive</button>
                        </div>
                        <div class="mt-4 space-y-2">
                            <input type="text" id="job-search-input" placeholder="Search jobs..." class="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-lg text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-blue-500">
                        </div>
                        <ul id="jobs-list" class="space-y-2 mt-4"></ul>
                    </div>
                </div>

                <!-- Driver UI -->
                <div id="driver-ui" class="hidden">
                    <div id="current-job-panel" class="hidden bg-blue-900 border border-blue-700 p-4 rounded-lg shadow-sm mt-4">
                        <h3 class="text-lg font-semibold text-white mb-2">My Current Job</h3>
                        <div id="current-job-details" class="text-sm text-blue-200 space-y-1"></div>
                        <div class="grid grid-cols-2 gap-2 mt-3">
                            <button id="start-navigation-btn" class="w-full px-3 py-1 bg-blue-600 text-white text-sm rounded hover:bg-blue-700">Navigate</button>
                            <button id="complete-job-btn" class="w-full px-3 py-1 bg-green-600 text-white text-sm rounded hover:bg-green-700">Complete</button>
                        </div>
                    </div>
                    <div id="available-jobs-panel" class="bg-gray-900 p-4 rounded-lg shadow-sm mt-4">
                        <h3 class="text-lg font-semibold text-gray-200 mb-2">Open Job Postings</h3>
                        <ul id="available-jobs-list" class="space-y-2"></ul>
                    </div>
                    <div id="driver-status-panel" class="bg-gray-900 p-4 rounded-lg shadow-sm mt-4">
                        <h2 class="text-lg font-semibold text-gray-200 mb-2">My Status</h2>
                        <div id="driver-status-control">
                            <label for="driver-status-select" class="block text-sm font-medium text-gray-300">Current Status:</label>
                            <select id="driver-status-select" class="mt-1 block w-full pl-3 pr-10 py-2 text-base bg-gray-700 border-gray-600 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md text-white">
                                <option>Available</option>
                                <option>On Break</option>
                            </select>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Modals -->
    <div id="profile-modal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
        <div class="bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-sm mx-4">
            <form id="profile-form">
                <h3 class="text-xl font-bold text-white mb-4">Edit Profile</h3>
                <div class="space-y-4">
                    <input type="text" id="profile-name-input" placeholder="Your Name" required class="w-full px-4 py-2 bg-gray-700 border border-gray-600 rounded-lg text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-blue-500">
                </div>
                <div class="flex justify-end space-x-2 mt-6">
                    <button type="button" id="profile-cancel-btn" class="px-4 py-2 bg-gray-600 text-white rounded-lg hover:bg-gray-700">Cancel</button>
                    <button type="submit" class="px-4 py-2 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700">Save</button>
                </div>
            </form>
        </div>
    </div>
    <div id="create-job-modal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
        <div class="bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-lg mx-4">
            <form id="create-job-form">
                <h3 class="text-xl font-bold text-white mb-4">Create New Job</h3>
                <div class="space-y-4">
                    <input type="text" id="job-name-input" placeholder="Job Name (e.g., Warehouse Delivery)" required class="w-full px-4 py-2 bg-gray-700 border border-gray-600 rounded-lg text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-blue-500">
                    <input type="text" id="job-origin-input" placeholder="Job Origin" required class="w-full px-4 py-2 bg-gray-700 border border-gray-600 rounded-lg text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-blue-500">
                    <input type="text" id="job-destination-input" placeholder="Job Destination" required class="w-full px-4 py-2 bg-gray-700 border border-gray-600 rounded-lg text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-blue-500">
                    <textarea id="job-note-input" placeholder="Job Notes (optional)" rows="2" class="w-full px-4 py-2 bg-gray-700 border border-gray-600 rounded-lg text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-blue-500"></textarea>
                    <div>
                        <label for="drivers-needed-input" class="block text-sm font-medium text-gray-300">Number of Drivers Needed:</label>
                        <input type="number" id="drivers-needed-input" min="1" max="9" value="1" required class="w-full mt-1 px-4 py-2 bg-gray-700 border border-gray-600 rounded-lg text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-blue-500">
                    </div>
                     <div>
                        <label for="assign-driver-select" class="block text-sm font-medium text-gray-300">Assign Driver (optional):</label>
                        <select id="assign-driver-select" class="w-full mt-1 px-4 py-2 bg-gray-700 border border-gray-600 rounded-lg text-white focus:outline-none focus:ring-2 focus:ring-blue-500">
                            <option value="">Post as open job</option>
                        </select>
                    </div>
                    <div class="flex justify-end space-x-2">
                        <button type="button" id="create-job-cancel-btn" class="px-4 py-2 bg-gray-600 text-white rounded-lg hover:bg-gray-700">Cancel</button>
                        <button type="submit" class="px-4 py-2 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 flex items-center justify-center w-32">
                            <span class="btn-text">Create Job</span>
                            <span class="spinner hidden ml-2"></span>
                        </button>
                    </div>
                </div>
            </form>
        </div>
    </div>
    <div id="confirm-modal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
        <div class="bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-sm mx-4">
            <h3 id="confirm-modal-title" class="text-xl font-bold text-white mb-4">Are you sure?</h3>
            <p id="confirm-modal-message" class="text-gray-300 mb-4"></p>
            <div class="flex justify-end space-x-2">
                <button id="confirm-cancel-btn" class="px-4 py-2 bg-gray-600 text-white rounded-lg hover:bg-gray-700">Cancel</button>
                <button id="confirm-action-btn" class="px-4 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700">Confirm</button>
            </div>
        </div>
    </div>
    <div id="job-details-modal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-[10000]">
        <div class="bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-lg mx-4 overflow-y-auto" style="max-height: 90vh;">
            <div id="job-details-printable">
                <div class="flex justify-between items-center mb-4">
                    <h3 class="text-2xl font-bold text-white">Job Details</h3>
                    <button id="job-details-close-btn" class="text-gray-400 hover:text-white text-3xl leading-none">&times;</button>
                </div>
                <div id="job-details-content" class="text-gray-300 space-y-2"></div>
                <div class="mt-4">
                    <h4 class="text-lg font-semibold text-white mb-2">Job History</h4>
                    <ul id="job-history-log" class="space-y-1 text-sm text-gray-400"></ul>
                </div>
                 <div class="mt-4">
                    <h4 class="text-lg font-semibold text-white mb-2">Messages</h4>
                    <div id="job-chat-box" class="h-40 bg-gray-900 rounded-md p-2 overflow-y-auto"></div>
                    <form id="job-chat-form" class="mt-2 flex space-x-2">
                        <input type="text" id="job-chat-input" placeholder="Type a message..." class="flex-grow px-3 py-2 bg-gray-700 border border-gray-600 rounded-lg text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-blue-500">
                        <button type="submit" class="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700">Send</button>
                    </form>
                </div>
            </div>
            <div class="mt-6 flex justify-end space-x-2">
                <button id="print-job-btn" class="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700">Print</button>
            </div>
        </div>
    </div>
    <div id="settings-modal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
        <div class="bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-md mx-4 overflow-y-auto" style="max-height: 90vh;">
            <h3 class="text-xl font-bold text-white mb-4">User Role Management</h3>
            <div id="settings-content" class="space-y-4">
                 <ul id="user-role-list" class="space-y-4">
                     <!-- User roles will be dynamically inserted here -->
                 </ul>
            </div>
             <button id="settings-cancel-btn" class="mt-6 w-full px-4 py-2 bg-gray-600 text-white rounded-lg hover:bg-gray-700">Close</button>
        </div>
    </div>


    <!-- Firebase SDK Imports -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, GoogleAuthProvider, signInWithPopup, signOut, onAuthStateChanged, signInWithCustomToken, signInAnonymously } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, doc, setDoc, onSnapshot, addDoc, serverTimestamp, GeoPoint, deleteDoc, query, where, getDocs, updateDoc, writeBatch, getDoc, arrayUnion, arrayRemove, runTransaction, enableIndexedDbPersistence } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        
        // --- Initialize Firebase and Services ---
        let app, auth, db;
        const SUPER_ADMIN_UID = 'QbXV0sMecoM7MhikQ4ftseSx0rv2';
        
        // --- UI Elements ---
        const loadingOverlay = document.getElementById('loading-overlay');
        const authContainer = document.getElementById('auth-container');
        const appContainer = document.getElementById('app-container');
        const googleSigninBtn = document.getElementById('google-signin-btn');
        const logoutBtn = document.getElementById('logout-btn');
        const settingsBtn = document.getElementById('settings-btn');
        const profileBtn = document.getElementById('profile-btn');

        const userIdEl = document.getElementById('userId');
        const driversListEl = document.getElementById('drivers-list');
        const jobsListEl = document.getElementById('jobs-list');
        const jobDashboardPanel = document.getElementById('job-dashboard-panel');
        const jobSearchInput = document.getElementById('job-search-input');
        const dispatchUi = document.getElementById('dispatch-ui');
        const driverUi = document.getElementById('driver-ui');
        const userWelcomeEl = document.getElementById('user-welcome');
        const driverStatusPanel = document.getElementById('driver-status-panel');
        const driverStatusControl = document.getElementById('driver-status-control');
        const driverStatusSelect = document.getElementById('driver-status-select');
        const availableJobsPanel = document.getElementById('available-jobs-panel');
        const availableJobsList = document.getElementById('available-jobs-list');
        const managementActionsPanel = document.getElementById('management-actions-panel');
        
        // Modals
        const profileModal = document.getElementById('profile-modal');
        const profileForm = document.getElementById('profile-form');
        const profileNameInput = document.getElementById('profile-name-input');
        const profileCancelBtn = document.getElementById('profile-cancel-btn');
        
        const createJobModal = document.getElementById('create-job-modal');
        const openCreateJobModalBtn = document.getElementById('open-create-job-modal-btn');
        const createJobForm = document.getElementById('create-job-form');
        const jobNameInput = document.getElementById('job-name-input');
        const jobOriginInput = document.getElementById('job-origin-input');
        const jobDestinationInput = document.getElementById('job-destination-input');
        const jobNoteInput = document.getElementById('job-note-input');
        const driversNeededInput = document.getElementById('drivers-needed-input');
        const assignDriverSelect = document.getElementById('assign-driver-select');
        const createJobCancelBtn = document.getElementById('create-job-cancel-btn');

        const currentJobPanel = document.getElementById('current-job-panel');
        const currentJobDetails = document.getElementById('current-job-details');
        const completeJobBtn = document.getElementById('complete-job-btn');
        const startNavigationBtn = document.getElementById('start-navigation-btn');

        const settingsModal = document.getElementById('settings-modal');
        const settingsCancelBtn = document.getElementById('settings-cancel-btn');
        const userRoleList = document.getElementById('user-role-list');
        
        const confirmModal = document.getElementById('confirm-modal');
        const confirmModalTitle = document.getElementById('confirm-modal-title');
        const confirmModalMessage = document.getElementById('confirm-modal-message');
        const confirmCancelBtn = document.getElementById('confirm-cancel-btn');
        const confirmActionBtn = document.getElementById('confirm-action-btn');

        const jobDetailsModal = document.getElementById('job-details-modal');
        const jobDetailsContent = document.getElementById('job-details-content');
        const jobHistoryLog = document.getElementById('job-history-log');
        const jobChatBox = document.getElementById('job-chat-box');
        const jobChatForm = document.getElementById('job-chat-form');
        const jobChatInput = document.getElementById('job-chat-input');
        const jobDetailsCloseBtn = document.getElementById('job-details-close-btn');
        const printJobBtn = document.getElementById('print-job-btn');


        // --- App State ---
        const AppState = {
            currentUser: null,
            map: null,
            trafficLayer: null,
            userMarker: null,
            driverMapMarkers: {},
            isSharingLocation: false,
            locationInterval: null,
            allUsers: [],
            allJobs: [],
            activeDrivers: [],
            activeJobTab: 'current',
            confirmCallback: null, 
            usersPath: '',
            driversPath: '',
            jobsPath: '',
            directionsService: null,
            directionsRenderer: null,
            unsubscribes: [],
            currentJobChatUnsubscribe: null,
        };

        // --- Main App Initialization ---
        function initMap() {
            const mapElement = document.getElementById("map");
            if (!window.google || !window.google.maps) {
                console.error("Google Maps script not loaded or API object not available.");
                mapElement.innerHTML = `<div class="text-center p-4"><p class="font-bold text-red-400">Map Error</p><p class="text-gray-400">Could not load Google Maps.</p></div>`;
                return;
            }
            mapElement.innerHTML = ''; 
            const mapOptions = {
                center: { lat: 39.8283, lng: -98.5795 }, // Center of the US
                zoom: 4,
                disableDefaultUI: true,
                styles: [ 
                    { elementType: "geometry", stylers: [{ color: "#242f3e" }] }, { elementType: "labels.text.stroke", stylers: [{ color: "#242f3e" }] }, { elementType: "labels.text.fill", stylers: [{ color: "#746855" }] }, { featureType: "administrative.locality", elementType: "labels.text.fill", stylers: [{ color: "#d59563" }] }, { featureType: "poi", elementType: "labels.text.fill", stylers: [{ color: "#d59563" }] }, { featureType: "poi.park", elementType: "geometry", stylers: [{ color: "#263c3f" }] }, { featureType: "poi.park", elementType: "labels.text.fill", stylers: [{ color: "#6b9a76" }] }, { featureType: "road", elementType: "geometry", stylers: [{ color: "#38414e" }] }, { featureType: "road", elementType: "geometry.stroke", stylers: [{ color: "#212a37" }] }, { featureType: "road", elementType: "labels.text.fill", stylers: [{ color: "#9ca5b3" }] }, { featureType: "road.highway", elementType: "geometry", stylers: [{ color: "#746855" }] }, { featureType: "road.highway", elementType: "geometry.stroke", stylers: [{ color: "#1f2835" }] }, { featureType: "road.highway", elementType: "labels.text.fill", stylers: [{ color: "#f3d19c" }] }, { featureType: "transit", elementType: "geometry", stylers: [{ color: "#2f3948" }] }, { featureType: "transit.station", elementType: "labels.text.fill", stylers: [{ color: "#d59563" }] }, { featureType: "water", elementType: "geometry", stylers: [{ color: "#17263c" }] }, { featureType: "water", elementType: "labels.text.fill", stylers: [{ color: "#515c6d" }] }, { featureType: "water", elementType: "labels.text.stroke", stylers: [{ color: "#17263c" }] },
                ],
            };
            AppState.map = new google.maps.Map(mapElement, mapOptions);
            AppState.directionsService = new google.maps.DirectionsService();
            AppState.directionsRenderer = new google.maps.DirectionsRenderer({
                map: AppState.map,
                polylineOptions: { strokeColor: '#4285F4', strokeWeight: 6, strokeOpacity: 0.8 },
                suppressMarkers: true 
            });
            AppState.trafficLayer = new google.maps.TrafficLayer();
            AppState.trafficLayer.setMap(AppState.map);
            
            const autocompleteOptions = {
                fields: ["address_components", "geometry", "icon", "name"],
                strictBounds: false,
            };
            const jobOriginAutocomplete = new google.maps.places.Autocomplete(jobOriginInput, autocompleteOptions);
            const jobDestinationAutocomplete = new google.maps.places.Autocomplete(jobDestinationInput, autocompleteOptions);
            jobOriginAutocomplete.bindTo("bounds", AppState.map);
            jobDestinationAutocomplete.bindTo("bounds", AppState.map);
        };

        async function initializeFirebase() {
            const hardcodedFirebaseConfig = {
                apiKey: "AIzaSyBGro7OUoAC1xXaBo8JjLnOQSFjZCmdoBI",
                authDomain: "route-tracker-e62b1.firebaseapp.com",
                projectId: "route-tracker-e62b1",
                storageBucket: "route-tracker-e62b1.appspot.com",
                messagingSenderId: "1016000331711",
                appId: "1:1016000331711:web:a122b8a52045ee4e832b0a",
                measurementId: "G-B476Z21SKP"
            };

            const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : hardcodedFirebaseConfig;
            const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';

            if (!firebaseConfig || !appId) {
                console.error("Firebase config or App ID not found. This application cannot run without it.");
                loadingOverlay.innerHTML = '<p class="text-red-400">Error: Application configuration is missing.</p>';
                return;
            }

            try {
                app = initializeApp(firebaseConfig);
                auth = getAuth(app);
                db = getFirestore(app);

                await enableIndexedDbPersistence(db);

                AppState.usersPath = `/artifacts/${appId}/public/data/users`;
                AppState.driversPath = `/artifacts/${appId}/public/data/driverLocations`;
                AppState.jobsPath = `/artifacts/${appId}/public/data/jobs`;
                
                onAuthStateChanged(auth, async (user) => {
                    loadingOverlay.classList.add('hidden');
                    if (user) {
                        await setupUserSession(user);
                    } else {
                        // Use custom token or anonymous sign-in if available
                        if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                            try {
                                await signInWithCustomToken(auth, __initial_auth_token);
                                // The onAuthStateChanged listener will be triggered again
                            } catch (error) {
                                console.error("Custom token sign-in failed, trying anonymous:", error);
                                await signInAnonymously(auth);
                            }
                        } else {
                           cleanupUserSession(); // Show Google Sign-in if no other method works
                        }
                    }
                });

            } catch (e) {
                console.error("Critical Firebase initialization error:", e);
                loadingOverlay.innerHTML = `<p class="text-red-400">Critical Error: ${e.message}</p>`;
            }
        }

        async function setupUserSession(user) {
            const userDocRef = doc(db, AppState.usersPath, user.uid);
            
            AppState.unsubscribes.push(onSnapshot(userDocRef, (userDocSnap) => {
                if (!userDocSnap.exists()) {
                    const defaultPermissions = {
                        canCreateJob: true,
                        canDeleteJob: false,
                        canManageDrivers: user.uid === SUPER_ADMIN_UID,
                        isDriver: false
                    };
                    setDoc(userDocRef, { 
                        email: user.email || user.uid, 
                        name: user.displayName || `User-${user.uid.substring(0, 4)}`,
                        permissions: defaultPermissions
                    });
                } else {
                    AppState.currentUser = { id: user.uid, ...userDocSnap.data() };

                    // Ensure Super Admin always has management rights, correcting if necessary.
                    if (user.uid === SUPER_ADMIN_UID && !AppState.currentUser.permissions.canManageDrivers) {
                        console.log("Correcting Super Admin permissions...");
                        const userRef = doc(db, AppState.usersPath, user.uid);
                        updateDoc(userRef, { "permissions.canManageDrivers": true })
                            .catch(err => console.error("Failed to correct Super Admin permissions:", err));
                        // The onSnapshot will re-trigger with the correct permissions.
                        return; // Avoid rendering with incorrect permissions temporarily
                    }
                    
                    userIdEl.textContent = AppState.currentUser.id; 
                    userWelcomeEl.textContent = `Welcome, ${AppState.currentUser.name}!`;
                    renderUIForPermissions();
                    
                    if (checkPermission('isDriver')) {
                        startAutomaticLocationSharing();
                    } else {
                        stopAutomaticLocationSharing();
                    }
                }
            }));
            
            authContainer.classList.add('hidden');
            appContainer.classList.remove('hidden');

            // Start other listeners
            AppState.unsubscribes.push(onSnapshot(collection(db, AppState.usersPath), (snapshot) => {
                AppState.allUsers = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            }));
            AppState.unsubscribes.push(onSnapshot(collection(db, AppState.driversPath), (snapshot) => {
                handleActiveDriversUpdate(snapshot);
            }));
            AppState.unsubscribes.push(onSnapshot(collection(db, AppState.jobsPath), (snapshot) => {
                AppState.allJobs = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                renderAllJobsList();
                if (checkPermission('isDriver')) {
                    listenForMyJob();
                    listenForOpenJobs();
                }
            }));
        }

        function cleanupUserSession() {
            stopAutomaticLocationSharing();
            AppState.unsubscribes.forEach(unsub => unsub());
            AppState.unsubscribes = [];
            AppState.currentUser = null;
            appContainer.classList.add('hidden');
            authContainer.classList.remove('hidden');
        }

        function checkPermission(permission) {
            return AppState.currentUser?.permissions?.[permission] === true;
        }
        
        function startAutomaticLocationSharing() {
            if (AppState.locationInterval) return; // Already sharing
            AppState.isSharingLocation = true;
            shareLocation(); 
            AppState.locationInterval = setInterval(shareLocation, 15000); 
        }

        function stopAutomaticLocationSharing() {
            if (AppState.locationInterval) {
                clearInterval(AppState.locationInterval);
                AppState.locationInterval = null;
            }
            if (AppState.currentUser) {
                deleteDoc(doc(db, AppState.driversPath, AppState.currentUser.id));
            }
            if (AppState.userMarker) {
                AppState.userMarker.setMap(null);
                AppState.userMarker = null;
            }
            AppState.isSharingLocation = false;
        }

        function shareLocation() {
            if (!navigator.geolocation) {
                showToast("Geolocation is not supported by your browser.", "error");
                return;
            }

            navigator.geolocation.getCurrentPosition(
                (position) => {
                    const newPos = {
                        lat: position.coords.latitude,
                        lng: position.coords.longitude,
                    };

                    if (AppState.map && !AppState.userMarker) {
                        AppState.userMarker = new google.maps.Marker({
                            position: newPos,
                            map: AppState.map,
                            title: 'Your Location',
                            icon: { path: google.maps.SymbolPath.CIRCLE, scale: 8, fillColor: '#4285F4', fillOpacity: 1, strokeColor: 'white', strokeWeight: 2 }
                        });
                    } else if (AppState.map && AppState.userMarker) {
                        AppState.userMarker.setPosition(newPos);
                    }

                    if (checkPermission('isDriver')) {
                        const locationData = {
                            location: new GeoPoint(newPos.lat, newPos.lng),
                            timestamp: serverTimestamp(),
                            status: driverStatusSelect.value,
                            name: AppState.currentUser.name
                        };
                        setDoc(doc(db, AppState.driversPath, AppState.currentUser.id), locationData, { merge: true });

                        const myCurrentJob = AppState.allJobs.find(job => job.status === 'in-progress' && job.assignedDrivers.includes(AppState.currentUser.id));
                        if(myCurrentJob){
                            calculateAndDisplayRoute(newPos, myCurrentJob.destination, myCurrentJob.id);
                        }
                    }
                },
                (error) => {
                    showToast(`Geolocation Error: ${error.message}`, "error");
                },
                { enableHighAccuracy: true }
            );
        }
        
        driverStatusSelect.addEventListener('change', () => {
            if (AppState.isSharingLocation && checkPermission('isDriver')) {
                const driverLocRef = doc(db, AppState.driversPath, AppState.currentUser.id);
                updateDoc(driverLocRef, { status: driverStatusSelect.value });
            }
        });

        function handleActiveDriversUpdate(snapshot) {
            const activeDriverDocs = snapshot.docs;
            AppState.activeDrivers = activeDriverDocs.map(doc => ({ id: doc.id, ...doc.data() }));
            renderDriversList();

            if (!AppState.map) return;

            const activeDriverIds = new Set(activeDriverDocs.map(doc => doc.id));

            for (const driverId in AppState.driverMapMarkers) {
                if (!activeDriverIds.has(driverId)) {
                    AppState.driverMapMarkers[driverId].setMap(null);
                    delete AppState.driverMapMarkers[driverId];
                }
            }

            activeDriverDocs.forEach(doc => {
                const driverId = doc.id;
                const docData = doc.data();

                if (driverId === AppState.currentUser?.id) return;

                const position = { lat: docData.location.latitude, lng: docData.location.longitude };

                if (AppState.driverMapMarkers[driverId]) {
                    AppState.driverMapMarkers[driverId].setPosition(position);
                } else {
                    AppState.driverMapMarkers[driverId] = new google.maps.Marker({
                        position,
                        map: AppState.map,
                        label: { text: docData.name ? docData.name.substring(0, 2).toUpperCase() : 'DR', color: "white", fontWeight: 'bold' },
                        icon: { path: google.maps.SymbolPath.CIRCLE, scale: 10, fillColor: '#f39c12', fillOpacity: 1, strokeColor: 'black', strokeWeight: 2 }
                    });
                }
            });
        }

        function renderDriversList() {
            driversListEl.innerHTML = '';
            if (AppState.activeDrivers.length === 0) {
                driversListEl.innerHTML = '<li class="text-gray-400 text-sm">No active drivers.</li>';
                return;
            }
            AppState.activeDrivers.forEach(driver => {
                const li = document.createElement('li');
                const borderClass = 'border-l-4 border-green-500';
                li.className = `flex justify-between items-center bg-gray-800 p-2 rounded-md ${borderClass}`;
                
                const status = driver.status || 'Online';
                let statusColor = 'bg-gray-500';
                if (status === 'Available') statusColor = 'bg-green-500';
                if (status === 'On Trip') statusColor = 'bg-yellow-500';
                if (status === 'On Break') statusColor = 'bg-orange-500';

                li.innerHTML = `
                    <div>
                        <p class="text-sm font-bold text-gray-200">${driver.name || 'Unnamed Driver'}</p>
                        <p class="text-xs text-gray-400">ETA: ${driver.eta || 'N/A'}</p>
                    </div>
                    <div class="flex items-center">
                         <span class="text-xs font-semibold text-gray-400 mr-2">${status}</span>
                         <span class="w-3 h-3 rounded-full ${statusColor} mr-2"></span>
                    </div>
                `;
                driversListEl.appendChild(li);
            });
        }
        
        function listenForAllJobs() {
            const jobsRef = collection(db, AppState.jobsPath);
            const unsubscribe = onSnapshot(jobsRef, (snapshot) => {
                AppState.allJobs = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                renderAllJobsList();
            });
            AppState.unsubscribes.push(unsubscribe);
        }

        function renderAllJobsList() {
            const isArchivedView = AppState.activeJobTab === 'archive';
            const searchTerm = jobSearchInput.value.toLowerCase();

            let jobsToRender = AppState.allJobs.filter(job => !!job.archived === isArchivedView);

            if (searchTerm) {
                jobsToRender = jobsToRender.filter(job => 
                    (job.jobName || '').toLowerCase().includes(searchTerm) ||
                    (job.origin || '').toLowerCase().includes(searchTerm) ||
                    (job.destination || '').toLowerCase().includes(searchTerm)
                );
            }

            const statusOrder = { 'unassigned': 1, 'in-progress': 2, 'completed': 3 };
            jobsToRender.sort((a, b) => {
                const orderA = statusOrder[a.status] || 4;
                const orderB = statusOrder[b.status] || 4;
                if (orderA !== orderB) return orderA - orderB;
                const timeA = a.createdAt ? a.createdAt.toMillis() : 0;
                const timeB = b.createdAt ? b.createdAt.toMillis() : 0;
                return timeB - timeA;
            });

            jobsListEl.innerHTML = '';
            if (jobsToRender.length === 0) {
                jobsListEl.innerHTML = `<li class="text-gray-400 text-sm">No jobs found.</li>`;
                return;
            }

            jobsToRender.forEach(job => {
                const li = document.createElement('li');
                li.dataset.jobId = job.id;
                let styleClasses = 'bg-gray-800 p-3 rounded-md text-sm cursor-pointer hover:bg-gray-700';

                const assignedDrivers = job.assignedDrivers || [];
                const assignedDriverNames = assignedDrivers
                    .map(driverId => {
                        const driver = AppState.allUsers.find(u => u.id === driverId);
                        return driver ? driver.name : 'Unknown';
                    })
                    .join(', ');

                const openings = `${assignedDrivers.length} of ${job.driversNeeded}`;
                const baseContent = `
                    <p class="font-bold text-white">${job.jobName || 'Unnamed Job'}</p>
                    <p class="text-gray-400"><strong class="text-gray-200">From:</strong> ${job.origin}</p>
                    <p class="text-gray-400"><strong class="text-gray-200">To:</strong> ${job.destination}</p>
                    <p class="text-gray-400"><strong class="text-gray-200">Openings:</strong> ${openings}</p>
                    ${assignedDriverNames ? `<p class="text-gray-400"><strong class="text-gray-200">Drivers:</strong> ${assignedDriverNames}</p>` : ''}
                `;
                
                const archiveButton = `<button data-job-id="${job.id}" class="archive-job-btn w-full mt-2 px-3 py-1 bg-gray-600 text-white text-xs rounded hover:bg-gray-500">Archive</button>`;
                const deleteButton = `<button data-job-id="${job.id}" class="delete-job-btn w-full mt-2 px-3 py-1 bg-red-800 text-white text-xs rounded hover:bg-red-700">Delete</button>`;
                const actionButtons = isArchivedView ? deleteButton : `<div class="grid grid-cols-2 gap-2">${archiveButton}${deleteButton}</div>`;

                switch(job.status) {
                    case 'unassigned': styleClasses += ' border-l-4 border-yellow-500'; break;
                    case 'in-progress': styleClasses += ' border-l-4 border-green-500'; break;
                    case 'completed': styleClasses += ' border-l-4 border-gray-600 opacity-80'; break;
                }
                li.className = styleClasses;
                li.innerHTML = baseContent + (checkPermission('canDeleteJob') ? actionButtons : '');
                jobsListEl.appendChild(li);
            });
        }

        async function deleteJob(jobId) {
            if (!checkPermission('canDeleteJob')) return;
            await deleteDoc(doc(db, AppState.jobsPath, jobId));
            showToast('Job has been deleted.', 'success');
        }

        async function archiveJob(jobId) {
            if (!checkPermission('canDeleteJob')) return;
            const jobRef = doc(db, AppState.jobsPath, jobId);
            await updateDoc(jobRef, { archived: true });
            showToast('Job has been archived.', 'success');
        }

        function listenForOpenJobs() {
            const q = query(
                collection(db, AppState.jobsPath),
                where("status", "in", ["unassigned", "in-progress"]),
                where("archived", "==", false)
            );

            const unsubscribe = onSnapshot(q, (snapshot) => {
                const openJobs = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                const availableJobs = openJobs.filter(job => {
                    const assignedDrivers = job.assignedDrivers || [];
                    const isFull = assignedDrivers.length >= job.driversNeeded;
                    const alreadyOnJob = assignedDrivers.includes(AppState.currentUser?.id);
                    return !isFull && !alreadyOnJob;
                });
                renderAvailableJobsList(availableJobs);
            });
            AppState.unsubscribes.push(unsubscribe);
        }

        function renderAvailableJobsList(jobs) {
            availableJobsList.innerHTML = '';
            if (jobs.length === 0) {
                availableJobsList.innerHTML = '<li class="text-gray-400 text-sm p-2">No job postings currently available.</li>';
                return;
            }

            jobs.forEach(job => {
                const li = document.createElement('li');
                li.className = 'bg-gray-800 p-3 rounded-md';
                const assignedCount = (job.assignedDrivers || []).length;
                
                li.innerHTML = `
                    <div class="flex justify-between items-start">
                        <div>
                            <p class="font-bold text-white">${job.jobName || 'Unnamed Job'}</p>
                            <p class="text-gray-300"><strong class="text-white">From:</strong> ${job.origin}</p>
                            <p class="text-gray-300"><strong class="text-white">To:</strong> ${job.destination}</p>
                            <p class="text-gray-300"><strong class="text-white">Openings:</strong> ${assignedCount} of ${job.driversNeeded}</p>
                            <p class="text-gray-400 mt-1 italic text-xs">${job.note || 'No notes'}</p>
                        </div>
                        <button data-job-id="${job.id}" class="accept-job-btn ml-2 px-3 py-1 bg-green-600 text-white text-xs font-semibold rounded hover:bg-green-700 flex-shrink-0">Accept</button>
                    </div>
                `;
                availableJobsList.appendChild(li);
            });
        }
        
        function calculateAndDisplayRoute(origin, destination, jobId) {
            if (!AppState.directionsService || !AppState.directionsRenderer) return;

            AppState.directionsService.route(
                {
                    origin: origin,
                    destination: destination,
                    travelMode: google.maps.TravelMode.DRIVING
                },
                (response, status) => {
                    if (status === "OK") {
                        AppState.directionsRenderer.setDirections(response);
                        const route = response.routes[0];
                        if (route && route.legs[0]) {
                            const leg = route.legs[0];
                            const eta = leg.duration.text;
                            const jobDetails = document.getElementById('current-job-details');
                            let etaEl = jobDetails.querySelector('.eta-display');
                            if (!etaEl) {
                                etaEl = document.createElement('p');
                                etaEl.className = 'eta-display font-bold text-green-300';
                                jobDetails.appendChild(etaEl);
                            }
                            etaEl.innerHTML = `<strong class="text-white">ETA:</strong> ${eta}`;
                            
                            const driverLocRef = doc(db, AppState.driversPath, AppState.currentUser.id);
                            updateDoc(driverLocRef, { eta: eta });

                            if (leg.distance.value <= 200) { // 200 meters for geofencing
                                completeJob(jobId, true); 
                            }
                        }
                    } else {
                        showToast("Directions request failed due to " + status, "error");
                    }
                }
            );
        }

        function clearRoute() {
            if (AppState.directionsRenderer) {
                AppState.directionsRenderer.setDirections({ routes: [] });
            }
        }

        function listenForMyJob() {
            const q = query(collection(db, AppState.jobsPath), where("assignedDrivers", "array-contains", AppState.currentUser?.id), where("status", "==", "in-progress"));
            const unsubscribe = onSnapshot(q, (snapshot) => {
                if (!snapshot.empty) {
                    const job = { id: snapshot.docs[0].id, ...snapshot.docs[0].data() };
                    currentJobPanel.classList.remove('hidden');
                    availableJobsPanel.classList.add('hidden'); 
                    currentJobDetails.innerHTML = `
                        <p class="font-bold text-white">${job.jobName || 'Unnamed Job'}</p>
                        <p><strong class="text-white">From:</strong> ${job.origin}</p>
                        <p><strong class="text-white">To:</strong> ${job.destination}</p>
                        <p class="mt-1 italic"><strong class="text-white">Note:</strong> ${job.note || 'N/A'}</p>
                    `;
                    completeJobBtn.dataset.jobId = job.id;
                    startNavigationBtn.dataset.destination = job.destination;

                    if (AppState.isSharingLocation && AppState.userMarker) {
                        const currentPosition = AppState.userMarker.getPosition();
                        calculateAndDisplayRoute(currentPosition, job.destination, job.id);
                    } else {
                        clearRoute();
                    }
                } else {
                    currentJobPanel.classList.add('hidden');
                    availableJobsPanel.classList.remove('hidden'); 
                    clearRoute();
                }
            });
            AppState.unsubscribes.push(unsubscribe);
        }

        function loadGoogleMapsScript() {
            const apiKey = "AIzaSyCHmVp6ImHZ37mB6XPm4x6pNODgt5PJjjg";
            const script = document.createElement('script');
            script.src = `https://maps.googleapis.com/maps/api/js?key=${apiKey}&libraries=places`;
            script.async = true;
            script.defer = true;
            script.onload = () => { console.log("Google Maps script loaded successfully."); initMap(); };
            script.onerror = () => { console.error("Error loading the Google Maps script."); document.getElementById("map").innerHTML = `<div class="text-center p-4"><p class="font-bold text-red-400">Map Script Error</p></div>`; };
            document.head.appendChild(script);
        }

        function showToast(message, type = 'info') {
            const toastContainer = document.getElementById('toast-container');
            const toast = document.createElement('div');
            toast.className = `p-4 mb-2 rounded-md shadow-lg text-white ${type === 'error' ? 'bg-red-600' : type === 'success' ? 'bg-green-600' : 'bg-blue-600'}`;
            toast.textContent = message;
            toastContainer.appendChild(toast);

            setTimeout(() => {
                toast.classList.add('opacity-0', 'transition-opacity', 'duration-300');
                setTimeout(() => {
                    toast.remove();
                }, 300);
            }, 3000);
        }

        function showConfirmModal(title, message, onConfirm) {
            confirmModalTitle.textContent = title;
            confirmModalMessage.textContent = message;
            AppState.confirmCallback = onConfirm; 
            confirmModal.classList.remove('hidden');
        }

        function showJobDetailsModal(job) {
            const assignedDrivers = (job.assignedDrivers || [])
                .map(id => AppState.allUsers.find(u => u.id === id)?.name || 'Unknown')
                .join(', ');
            const createdTime = job.createdAt ? job.createdAt.toDate().toLocaleString() : 'N/A';
            
            jobDetailsContent.innerHTML = `
                <p><strong>Job Name:</strong> ${job.jobName || 'N/A'}</p>
                <p><strong>Status:</strong> ${job.status}</p>
                <p><strong>From:</strong> ${job.origin}</p>
                <p><strong>To:</strong> ${job.destination}</p>
                <p><strong>Drivers Needed:</strong> ${job.driversNeeded}</p>
                <p><strong>Assigned Drivers:</strong> ${assignedDrivers || 'None'}</p>
                <p><strong>Created:</strong> ${createdTime}</p>
                <p class="mt-2 italic"><strong class="text-white">Note:</strong> ${job.note || 'N/A'}</p>
            `;

            jobHistoryLog.innerHTML = '';
            if (job.log && job.log.length > 0) {
                job.log.forEach(entry => {
                    const li = document.createElement('li');
                    const entryTime = entry.timestamp ? entry.timestamp.toDate().toLocaleString() : '';
                    li.textContent = `[${entryTime}] ${entry.text}`;
                    jobHistoryLog.appendChild(li);
                });
            } else {
                jobHistoryLog.innerHTML = '<li>No history entries.</li>';
            }

            jobChatForm.dataset.jobId = job.id;
            listenForJobMessages(job.id);
            jobDetailsModal.classList.remove('hidden');
        }

        function renderUIForPermissions() {
            // Reset UI states
            dispatchUi.classList.add('hidden');
            driverUi.classList.add('hidden');
            settingsBtn.classList.add('hidden');
            managementActionsPanel.classList.add('hidden'); // Hide by default

            // Determine primary role UI
            if (checkPermission('isDriver')) {
                driverUi.classList.remove('hidden');
            } else {
                dispatchUi.classList.remove('hidden');
                // For dispatchers, check for specific action permissions
                if (checkPermission('canCreateJob')) {
                    managementActionsPanel.classList.remove('hidden');
                }
            }

            // Check for secondary permissions like settings
            if (checkPermission('canManageDrivers')) {
                settingsBtn.classList.remove('hidden');
            }
        }
        
        function showSpinner(button) {
            button.disabled = true;
            const btnText = button.querySelector('.btn-text');
            const spinner = button.querySelector('.spinner');
            if (btnText) btnText.classList.add('hidden');
            if (spinner) spinner.classList.remove('hidden');
        }

        function hideSpinner(button) {
            button.disabled = false;
            const btnText = button.querySelector('.btn-text');
            const spinner = button.querySelector('.spinner');
            if (btnText) btnText.classList.remove('hidden');
            if (spinner) spinner.classList.add('hidden');
        }
        
        // --- Event Listeners ---
        
        logoutBtn.addEventListener('click', async () => {
            await stopAutomaticLocationSharing();
            signOut(auth).catch((error) => console.error('Logout Error:', error));
        });

        googleSigninBtn.addEventListener('click', async () => {
            const provider = new GoogleAuthProvider();
            try {
                await signInWithPopup(auth, provider);
            } catch (error) {
                showToast('Google Sign-In Error: ' + error.message, 'error');
            }
        });

        profileBtn.addEventListener('click', () => {
            profileNameInput.value = AppState.currentUser.name;
            profileModal.classList.remove('hidden');
        });

        profileForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            const newName = profileNameInput.value.trim();
            if (newName && newName !== AppState.currentUser.name) {
                const userDocRef = doc(db, AppState.usersPath, AppState.currentUser.id);
                await updateDoc(userDocRef, { name: newName });
                showToast('Profile updated!', 'success');
            }
            profileModal.classList.add('hidden');
        });

        profileCancelBtn.addEventListener('click', () => profileModal.classList.add('hidden'));

        settingsBtn.addEventListener('click', () => {
            renderUserRoleManagement();
            settingsModal.classList.remove('hidden');
        });
        
        settingsCancelBtn.addEventListener('click', () => settingsModal.classList.add('hidden'));

        openCreateJobModalBtn.addEventListener('click', () => {
            const availableDrivers = AppState.allUsers.filter(u => u.permissions?.isDriver && !AppState.activeDrivers.some(d => d.id === u.id && d.status === 'On Trip'));
            assignDriverSelect.innerHTML = '<option value="">Post as open job</option>';
            availableDrivers.forEach(driver => {
                const option = document.createElement('option');
                option.value = driver.id;
                option.textContent = driver.name;
                assignDriverSelect.appendChild(option);
            });
            createJobModal.classList.remove('hidden');
        });
        createJobCancelBtn.addEventListener('click', () => createJobModal.classList.add('hidden'));

        jobDashboardPanel.addEventListener('click', (e) => {
            if (e.target.matches('.tab-btn')) {
                jobDashboardPanel.querySelector('.tab-btn.active').classList.remove('active');
                e.target.classList.add('active');
                AppState.activeJobTab = e.target.dataset.tab;
                renderAllJobsList();
            }
        });

        jobSearchInput.addEventListener('input', renderAllJobsList);

        jobsListEl.addEventListener('click', (e) => {
            const button = e.target.closest('button');
            if (button) {
                const jobId = button.dataset.jobId;
                if (button.classList.contains('delete-job-btn')) {
                    showConfirmModal('Delete Job?', 'This action is permanent and cannot be undone. Are you sure?', () => deleteJob(jobId));
                } else if (button.classList.contains('archive-job-btn')) {
                    archiveJob(jobId);
                }
            } else if (e.target.closest('li[data-job-id]')) {
                const jobId = e.target.closest('li[data-job-id]').dataset.jobId;
                const job = AppState.allJobs.find(j => j.id === jobId);
                if (job) showJobDetailsModal(job);
            }
        });

        availableJobsList.addEventListener('click', async (e) => {
            if (e.target.classList.contains('accept-job-btn')) {
                const button = e.target;
                const { jobId } = button.dataset;

                button.disabled = true;
                button.textContent = 'Accepting...';

                const jobRef = doc(db, AppState.jobsPath, jobId);
                
                try {
                    await runTransaction(db, async (transaction) => {
                        const jobDoc = await transaction.get(jobRef);
                        if (!jobDoc.exists()) throw "Job does not exist!";
                        
                        const jobData = jobDoc.data();
                        const assignedDrivers = jobData.assignedDrivers || [];

                        if (assignedDrivers.includes(AppState.currentUser.id)) throw "You have already accepted this job.";
                        if (assignedDrivers.length >= jobData.driversNeeded) throw "All driver slots for this job are now filled.";
                        
                        const newAssignedDrivers = [...assignedDrivers, AppState.currentUser.id];
                        const isNowFull = newAssignedDrivers.length >= jobData.driversNeeded;
                        
                        const newLogEntry = { text: `Accepted by ${AppState.currentUser.name}`, timestamp: serverTimestamp() };

                        transaction.update(jobRef, { 
                            status: isNowFull ? 'in-progress' : 'unassigned',
                            assignedDrivers: arrayUnion(AppState.currentUser.id),
                            log: arrayUnion(newLogEntry)
                        });

                        if (AppState.isSharingLocation) {
                            const driverLocRef = doc(db, AppState.driversPath, AppState.currentUser.id);
                            transaction.update(driverLocRef, { status: 'On Trip' });
                        }
                    });
                    showToast("Job accepted!", "success");
                } catch (error) {
                    console.error("Error accepting job:", error);
                    showToast(error.toString(), "error");
                    button.disabled = false;
                    button.textContent = 'Accept';
                }
            }
        });
        
        async function completeJob(jobId, isAuto = false) {
             const jobRef = doc(db, AppState.jobsPath, jobId);
            try {
                await runTransaction(db, async (transaction) => {
                    const jobDoc = await transaction.get(jobRef);
                    if (!jobDoc.exists()) throw "Job not found";
                    
                    const jobData = jobDoc.data();
                    const assignedDrivers = jobData.assignedDrivers || [];
                    
                    if (!assignedDrivers.includes(AppState.currentUser.id)) {
                        return; // Already completed or not on job
                    }

                    const remainingDrivers = assignedDrivers.filter(id => id !== AppState.currentUser.id);
                    const newLogEntry = { text: `Completed by ${AppState.currentUser.name}`, timestamp: serverTimestamp() };

                    if (remainingDrivers.length === 0) {
                        transaction.update(jobRef, { status: 'completed', assignedDrivers: arrayRemove(AppState.currentUser.id), log: arrayUnion(newLogEntry) });
                    } else {
                        transaction.update(jobRef, { assignedDrivers: arrayRemove(AppState.currentUser.id), log: arrayUnion(newLogEntry) });
                    }

                    if (AppState.isSharingLocation) {
                        const driverLocRef = doc(db, AppState.driversPath, AppState.currentUser.id);
                        transaction.update(driverLocRef, { status: 'Available', eta: '' });
                    }
                });
                showToast(isAuto ? "Arrived at destination! Job auto-completed." : "You have completed your part of the job!", "success");
            } catch (error) {
                console.error("Error completing job:", error);
                showToast("Could not complete job.", "error");
            }
        }

        completeJobBtn.addEventListener('click', (e) => {
            const jobId = e.target.dataset.jobId;
            completeJob(jobId);
        });

        startNavigationBtn.addEventListener('click', (e) => {
            const destination = e.target.dataset.destination;
            if (destination) {
                const url = `https://www.google.com/maps/dir/?api=1&destination=${encodeURIComponent(destination)}&travelmode=driving`;
                window.open(url, '_blank');
            }
        });

        // Form Submissions
        createJobForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            if (!checkPermission('canCreateJob')) return;
            const button = e.submitter;
            showSpinner(button);
            const jobName = jobNameInput.value.trim();
            const origin = jobOriginInput.value.trim();
            const destination = jobDestinationInput.value.trim();
            const driversNeeded = parseInt(driversNeededInput.value, 10);
            const note = jobNoteInput.value.trim();
            const assignedDriverId = assignDriverSelect.value;

            if (!jobName || !origin || !destination || !driversNeeded) { showToast('Please fill out all required fields.', 'error'); hideSpinner(button); return; }
            
            const initialLog = [{ text: `Created by ${AppState.currentUser.name}`, timestamp: serverTimestamp() }];
            const jobData = { 
                jobName, origin, destination, note, 
                driversNeeded, 
                assignedDrivers: [], 
                createdAt: serverTimestamp(), 
                declinedBy: [], 
                archived: false,
                log: initialLog
            };

            if (assignedDriverId) {
                jobData.assignedDrivers.push(assignedDriverId);
                jobData.status = 'in-progress';
                const assignedDriver = AppState.allUsers.find(u => u.id === assignedDriverId);
                jobData.log.push({ text: `Assigned to ${assignedDriver.name}`, timestamp: serverTimestamp() });
            } else {
                jobData.status = 'unassigned';
            }

            await addDoc(collection(db, AppState.jobsPath), jobData);
            showToast('New job has been created.', 'success');
            createJobForm.reset();
            createJobModal.classList.add('hidden');
            hideSpinner(button);
        });

        function renderUserRoleManagement() {
            userRoleList.innerHTML = '';
            const permissions = ['isDriver', 'canCreateJob', 'canDeleteJob', 'canManageDrivers'];

            AppState.allUsers.forEach(user => {
                const li = document.createElement('li');
                li.className = 'bg-gray-700 p-3 rounded';
                
                let checkboxesHTML = permissions.map(perm => {
                    const isChecked = user.permissions?.[perm] === true;
                    const isDisabled = user.id === SUPER_ADMIN_UID && perm === 'canManageDrivers';
                    return `
                        <label class="flex items-center space-x-2">
                            <input type="checkbox" data-user-id="${user.id}" data-permission="${perm}" 
                                   class="permission-checkbox bg-gray-600 border-gray-500 rounded" 
                                   ${isChecked ? 'checked' : ''} ${isDisabled ? 'disabled' : ''}>
                            <span class="text-sm">${perm}</span>
                        </label>
                    `;
                }).join('');

                li.innerHTML = `
                    <p class="text-sm font-bold text-gray-200 truncate mb-2">${user.email || user.id}</p>
                    <div class="grid grid-cols-2 gap-2">
                        ${checkboxesHTML}
                    </div>
                `;
                userRoleList.appendChild(li);
            });
        }

        userRoleList.addEventListener('change', async (e) => {
            if (e.target.classList.contains('permission-checkbox')) {
                const { userId, permission } = e.target.dataset;
                const isChecked = e.target.checked;

                const userDocRef = doc(db, AppState.usersPath, userId);
                const permissionPath = `permissions.${permission}`;

                await updateDoc(userDocRef, { [permissionPath]: isChecked });

                if (permission === 'isDriver' && !isChecked) {
                    await deleteDoc(doc(db, AppState.driversPath, userId));
                }

                showToast('Permissions updated.', 'success');
            }
        });

        function listenForJobMessages(jobId) {
            if (AppState.currentJobChatUnsubscribe) {
                AppState.currentJobChatUnsubscribe();
            }
            const messagesRef = collection(db, AppState.jobsPath, jobId, 'messages');
            const q = query(messagesRef);
            
            AppState.currentJobChatUnsubscribe = onSnapshot(q, (snapshot) => {
                jobChatBox.innerHTML = '';
                const messages = snapshot.docs.map(d => d.data());
                messages.sort((a, b) => a.timestamp - b.timestamp);
                messages.forEach(msg => {
                    const msgEl = document.createElement('div');
                    const isMe = msg.senderId === AppState.currentUser.id;
                    msgEl.className = `flex ${isMe ? 'justify-end' : 'justify-start'} mb-2`;
                    msgEl.innerHTML = `
                        <div class="rounded-lg px-3 py-2 ${isMe ? 'bg-blue-600 text-white' : 'bg-gray-700 text-gray-200'}">
                            <p class="text-sm font-bold">${msg.senderName}</p>
                            <p class="text-sm">${msg.text}</p>
                        </div>
                    `;
                    jobChatBox.appendChild(msgEl);
                });
                jobChatBox.scrollTop = jobChatBox.scrollHeight;
            });
        }

        jobChatForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            const jobId = e.target.dataset.jobId;
            const text = jobChatInput.value.trim();
            if (!text || !jobId) return;

            const messagesRef = collection(db, AppState.jobsPath, jobId, 'messages');
            await addDoc(messagesRef, {
                text,
                senderId: AppState.currentUser.id,
                senderName: AppState.currentUser.name,
                timestamp: serverTimestamp()
            });
            jobChatInput.value = '';
        });

        // Modal Close Buttons
        profileCancelBtn.addEventListener('click', () => profileModal.classList.add('hidden'));
        settingsCancelBtn.addEventListener('click', () => settingsModal.classList.add('hidden'));
        createJobCancelBtn.addEventListener('click', () => createJobModal.classList.add('hidden'));
        jobDetailsCloseBtn.addEventListener('click', () => {
            if (AppState.currentJobChatUnsubscribe) {
                AppState.currentJobChatUnsubscribe();
                AppState.currentJobChatUnsubscribe = null;
            }
            jobDetailsModal.classList.add('hidden');
        });
        confirmCancelBtn.addEventListener('click', () => {
            confirmModal.classList.add('hidden');
            AppState.confirmCallback = null;
        });
        confirmActionBtn.addEventListener('click', () => {
            if (typeof AppState.confirmCallback === 'function') {
                AppState.confirmCallback();
            }
            confirmModal.classList.add('hidden');
            AppState.confirmCallback = null;
        });
        printJobBtn.addEventListener('click', () => window.print());

        window.onload = () => {
            initializeFirebase();
            loadGoogleMapsScript();
        };

    </script>
    
</body>
</html>
