<!--
Vecto Mapping System
Wolfe.BT
TangentLLC
--><!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vecto - Dark</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/qrcodejs@1.0.0/qrcode.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@100;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; }
        #map, #public-map, #public-driver-map { height: 100%; width: 100%; }
        /* Custom scrollbar for dark theme */
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #1f2937; } /* gray-800 */
        ::-webkit-scrollbar-thumb { background: #4b5563; border-radius: 4px; } /* gray-600 */
        ::-webkit-scrollbar-thumb:hover { background: #6b7280; } /* gray-500 */
        
        /* Style for disabled buttons */
        button:disabled {
            background-color: #4b5563; /* gray-600 */
            cursor: not-allowed;
            opacity: 0.7;
        }
        /* Styling for Google Places Autocomplete dropdown */
        .pac-container {
            background-color: #1f2937; /* gray-800 */
            border-radius: 0.5rem;
            border: 1px solid #4b5563; /* gray-600 */
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            z-index: 10005 !important; /* Ensure it's above other modals */
        }
        .pac-item {
            padding: 0.5rem 1rem;
            cursor: pointer;
            color: #d1d5db; /* gray-300 */
            border-top: 1px solid #374151; /* gray-700 */
        }
        .pac-item:first-child {
            border-top: none;
        }
        .pac-item:hover {
            background-color: #374151; /* gray-700 */
        }
        .pac-item-query {
            color: #f9fafb; /* gray-50 */
            font-weight: 500;
        }
        .pac-matched {
            color: #60a5fa; /* blue-400 */
        }
        
        /* Spinner */
        .spinner {
            display: inline-block;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: #fff;
            width: 1rem;
            height: 1rem;
            animation: spin 1s ease-in-out infinite;
        }
        .large-spinner {
             width: 3rem;
             height: 3rem;
             border-width: 4px;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        .tab-btn.active {
            border-bottom-color: #0d9488; /* teal-600 */
            color: #e5e7eb; /* gray-200 */
        }

        .pulse-border {
            animation: pulse-animation 2s infinite;
        }

        @keyframes pulse-animation {
            0% { box-shadow: 0 0 0 0 rgba(156, 163, 175, 0.4); }
            70% { box-shadow: 0 0 0 10px rgba(156, 163, 175, 0); }
            100% { box-shadow: 0 0 0 0 rgba(156, 163, 175, 0); }
        }

        @media print {
            body * {
                visibility: hidden;
            }
            #job-details-printable, #job-details-printable * {
                visibility: visible;
            }
            #job-details-printable {
                position: absolute;
                left: 0;
                top: 0;
                width: 100%;
                background-color: white;
                color: black;
            }
            #job-details-modal > div {
                max-height: none !important;
            }
            #job-details-printable h3, #job-details-printable strong, #job-details-printable p, #job-details-printable span, #job-details-printable li, .creator-tag-print {
                color: black !important;
            }
            #job-details-printable button, #job-details-printable form {
                display: none;
            }
            #job-chat-box {
                border: 1px solid #ccc;
                height: auto !important;
                overflow-y: visible !important;
            }
            #job-chat-box .chat-message {
                background-color: transparent !important;
                padding: 2px 0 !important;
                border-bottom: 1px dotted #ccc;
            }
            #job-chat-box .chat-message > div {
                 background: none !important;
            }
            #job-chat-box .chat-message p {
                color: black !important;
            }
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-200">

    <!-- Offline Banner -->
    <div id="offline-banner" class="hidden fixed top-0 left-0 right-0 bg-yellow-600 text-white text-center p-2 z-[10002]">
        You are currently offline. Data may not be up-to-date.
    </div>

    <!-- Fullscreen Loader -->
    <div id="loading-overlay" class="fixed inset-0 bg-gray-900 flex items-center justify-center z-[10001]">
        <div class="text-center">
            <div class="spinner large-spinner mx-auto"></div>
            <p class="text-gray-400 mt-4">Connecting to Route Tracker...</p>
        </div>
    </div>

    <!-- Toast Container -->
    <div id="toast-container" class="fixed top-4 right-4 z-[10000]"></div>

    <!-- Auth Container -->
    <div id="auth-container" class="hidden flex items-center justify-center h-screen">
        <div class="w-full max-w-sm text-center">
             <h1 class="text-4xl font-bold text-white mb-2">Vecto</h1>
             <p class="text-gray-400 mb-8">Please sign in to continue</p>
             <button id="google-signin-btn" class="bg-white text-gray-800 font-bold py-3 px-6 rounded-lg shadow-md hover:bg-gray-200 flex items-center justify-center w-full">
                 <svg class="w-6 h-6 mr-3" viewBox="0 0 48 48"><path fill="#EA4335" d="M24 9.5c3.54 0 6.71 1.22 9.21 3.6l6.85-6.85C35.9 2.38 30.47 0 24 0 14.62 0 6.51 5.38 2.56 13.22l7.98 6.19C12.43 13.72 17.74 9.5 24 9.5z"></path><path fill="#4285F4" d="M46.98 24.55c0-1.57-.15-3.09-.38-4.55H24v9.02h12.94c-.58 2.96-2.26 5.48-4.78 7.18l7.73 6c4.51-4.18 7.09-10.36 7.09-17.65z"></path><path fill="#FBBC05" d="M10.53 28.59c-.48-1.45-.76-2.99-.76-4.59s.27-3.14.76-4.59l-7.98-6.19C.92 16.46 0 20.12 0 24c0 3.88.92 7.54 2.56 10.78l7.97-6.19z"></path><path fill="#34A853" d="M24 48c6.48 0 11.93-2.13 15.89-5.81l-7.73-6c-2.15 1.45-4.92 2.3-8.16 2.3-6.26 0-11.57-4.22-13.47-9.91l-7.98 6.19C6.51 42.62 14.62 48 24 48z"></path><path fill="none" d="M0 0h48v48H0z"></path></svg>
                 Sign in with Google
             </button>
        </div>
    </div>

    <!-- App Container -->
    <!-- SCROLL FIX: Changed h-screen to md:h-screen to allow scrolling on mobile -->
    <div id="app-container" class="hidden flex flex-col md:flex-row md:h-screen">
        <!-- Map View -->
        <!-- SCROLL FIX: Changed h-[40vh] to h-96 for a fixed but scrollable height on mobile -->
        <div id="map-container" class="w-full md:w-2/3 h-96 md:h-full">
            <div id="map" class="rounded-lg shadow-md bg-gray-700 flex items-center justify-center">
                <p class="text-gray-400">Loading Map...</p>
            </div>
        </div>

        <!-- Sidebar -->
        <!-- SCROLL FIX: Removed h-[60vh] to allow natural height on mobile -->
        <div class="w-full md:w-1/3 md:h-full flex flex-col bg-gray-800 p-4 space-y-4 overflow-y-auto border-l-2 border-teal-600">
            <div id="sidebar-content" class="flex flex-col h-full relative">
                <!-- Sidebar Loading Overlay -->
                <div id="sidebar-loader" class="absolute inset-0 bg-gray-800 bg-opacity-75 flex-col items-center justify-center z-10 hidden">
                    <div class="spinner large-spinner"></div>
                    <p class="text-gray-300 mt-4">Loading Company Data...</p>
                </div>

                <div>
                    <div class="flex items-center justify-between pb-2 border-b border-gray-700">
                        <h1 class="text-2xl font-bold text-white">Vecto</h1>
                        <div class="flex items-center space-x-4">
                            <button id="settings-btn" class="text-gray-400 hover:text-white">
                                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path></svg>
                            </button>
                            <button id="logout-btn" class="text-sm text-red-400 hover:text-red-300">Logout</button>
                        </div>
                    </div>
                    <div class="flex items-center justify-between pt-2">
                        <div class="flex items-center space-x-2">
                            <h2 id="user-welcome" class="text-lg font-semibold text-gray-200">Welcome!</h2>
                            <span id="admin-badge" class="hidden bg-indigo-600 text-white text-xs font-semibold px-2.5 py-0.5 rounded-full">Admin</span>
                        </div>
                    </div>
                    
                    <div id="company-selection-panel" class="bg-gray-900 p-4 rounded-lg shadow-sm mt-4">
                        <button id="select-company-btn" class="w-full px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700">
                            <span id="select-company-btn-label" class="text-[1.5rem] leading-snug underline font-semibold">Select/Change Company</span>
                        </button>
                    </div>

                    <!-- Dispatcher UI -->
                    <div id="dispatch-ui" class="hidden">
                        <div id="management-actions-panel" class="bg-gray-900 p-4 rounded-lg shadow-sm mt-4">
                            <div id="dispatcher-actions" class="grid grid-cols-1 gap-2">
                                <button id="open-create-job-modal-btn" class="w-full px-4 py-2 bg-teal-600 text-white rounded-lg hover:bg-teal-700">Create Job</button>
                                <button id="walking-mode-btn" class="w-full px-4 py-2 bg-purple-600 text-white rounded-lg hover:bg-purple-700 mt-2">Walking Mode</button>
                            </div>
                        </div>
                        <div id="job-dashboard-panel" class="bg-gray-900 p-4 rounded-lg shadow-sm mt-4">
                            <div class="flex border-b border-gray-700">
                                <button data-tab="current" class="tab-btn flex-1 py-2 text-center font-semibold text-gray-400 border-b-2 border-transparent hover:border-gray-500 hover:text-gray-300 active">Current</button>
                                <button data-tab="archive" class="tab-btn flex-1 py-2 text-center font-semibold text-gray-400 border-b-2 border-transparent hover:border-gray-500 hover:text-gray-300">Archive</button>
                            </div>
                            <div class="mt-4 space-y-2">
                                <input type="text" id="job-search-input" placeholder="Search jobs..." class="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-lg text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-blue-500">
                            </div>
                            <ul id="jobs-list" class="space-y-2 mt-4"></ul>
                        </div>
                        <div id="drivers-panel" class="bg-gray-900 p-4 rounded-lg shadow-sm mt-4">
                            <div class="flex justify-between items-center mb-2">
                                <h3 class="text-lg font-semibold text-gray-200">Drivers</h3>
                                <button id="refresh-drivers-btn" class="p-1 rounded-full hover:bg-gray-700" title="Refresh List">
                                    <svg class="w-5 h-5 text-gray-300" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17.65 6.35C16.2 4.9 14.21 4 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z"></path></svg>
                                </button>
                            </div>
                            <ul id="drivers-list" class="space-y-2"></ul>
                        </div>

                        <div id="geofence-panel" class="bg-gray-900 p-4 rounded-lg shadow-sm mt-4">
                            <div class="flex justify-between items-center mb-2">
                                <h3 class="text-lg font-semibold text-gray-200">Geofences</h3>
                                <button id="create-geofence-btn" class="px-3 py-1 bg-blue-600 text-white text-sm rounded hover:bg-blue-700">Create</button>
                            </div>
                            <ul id="geofences-list" class="space-y-2"></ul>
                        </div>

                        <div id="trail-creation-panel" class="hidden bg-gray-900 p-4 rounded-lg shadow-sm mt-4">
                            <h3 class="text-lg font-semibold text-gray-200 mb-2">Trail Creation</h3>
                            <div class="space-y-2">
                                <button id="start-recording-btn" class="w-full px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700">Start Recording</button>
                                <button id="drop-point-btn" class="w-full px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 hidden">Drop Point</button>
                                <div class="flex items-center justify-center hidden" id="auto-record-container">
                                    <input id="auto-record-switch" type="checkbox" class="h-4 w-4 text-teal-600 bg-gray-700 border-gray-600 rounded focus:ring-teal-500">
                                    <label for="auto-record-switch" class="ml-2 block text-sm text-gray-300">Auto-record</label>
                                </div>
                                <button id="finish-save-btn" class="w-full px-4 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700 hidden">Finish & Save</button>
                                <div id="trail-navigation-container" class="hidden mt-2 space-y-2">
                                    <button id="navigate-to-trail-btn" class="w-full px-4 py-2 bg-orange-600 text-white rounded-lg hover:bg-orange-700">Navigate to Nearest Point</button>
                                    <button id="navigate-to-start-btn" class="w-full px-4 py-2 bg-sky-600 text-white rounded-lg hover:bg-sky-700">Navigate to Start</button>
                                </div>
                            </div>
                        </div>

                        <div id="saved-trails-panel" class="hidden bg-gray-900 p-4 rounded-lg shadow-sm mt-4">
                            <h3 class="text-lg font-semibold text-gray-200 mb-2">Saved Trails</h3>
                            <ul id="saved-trails-list" class="space-y-2"></ul>
                        </div>
                    </div>

                    <!-- Driver UI -->
                    <div id="driver-ui" class="hidden">
                        <div id="current-job-panel" class="hidden bg-blue-900 border border-blue-700 p-4 rounded-lg shadow-sm mt-4 cursor-pointer">
                            <h3 class="text-lg font-semibold text-white mb-2">My Current Job</h3>
                            <div id="current-job-details" class="text-sm text-blue-200 space-y-1"></div>
                            <div class="grid grid-cols-2 gap-2 mt-3">
                                <button id="start-navigation-btn" class="w-full px-3 py-1 bg-blue-600 text-white text-sm rounded hover:bg-blue-700">Navigate</button>
                                <button id="complete-job-btn" class="w-full px-3 py-1 bg-green-600 text-white text-sm rounded hover:bg-green-700">Complete</button>
                            </div>
                             <button id="arrived-btn" class="hidden w-full mt-3 px-4 py-2 bg-yellow-500 text-white font-bold rounded-lg hover:bg-yellow-600 animate-pulse">Arrived? Mark as Complete</button>
                        </div>
                        <div id="available-jobs-panel" class="bg-gray-900 p-4 rounded-lg shadow-sm mt-4">
                            <h3 class="text-lg font-semibold text-gray-200 mb-2">Open Job Postings</h3>
                            <ul id="available-jobs-list" class="space-y-2"></ul>
                        </div>
                        <div id="driver-status-panel" class="bg-gray-900 p-4 rounded-lg shadow-sm mt-4">
                            <h2 class="text-lg font-semibold text-gray-200 mb-2">My Status</h2>
                            <div id="driver-status-control" class="space-y-2">
                                <label for="driver-status-select" class="block text-sm font-medium text-gray-300">Current Status:</label>
                                <select id="driver-status-select" class="mt-1 block w-full pl-3 pr-10 py-2 text-base bg-gray-700 border-gray-600 focus:outline-none focus:ring-teal-500 focus:border-teal-500 sm:text-sm rounded-md text-white">
                                    <option>Available</option>
                                    <option>On Break</option>
                                </select>
                                <button id="share-location-btn" class="w-full px-4 py-2 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700">Share Location</button>
                            </div>
                        </div>
                    </div>
                </div>
                <!-- Creator ID Tag -->
                <div class="mt-auto pt-4 text-center text-xs font-thin text-gray-500">
                    <p>Vecto</p>
                    <p>Wolfe.BT@TangentLLC</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Public Job View Container -->
    <!-- SCROLL FIX: Changed h-screen to md:h-screen to allow scrolling on mobile -->
    <div id="public-job-container" class="hidden flex flex-col md:flex-row md:h-screen">
        <!-- Public Map View -->
        <!-- SCROLL FIX: Changed h-[40vh] to h-96 for a fixed but scrollable height on mobile -->
        <div id="public-map-container" class="w-full md:w-2/3 h-96 md:h-full">
            <div id="public-map" class="rounded-lg shadow-md bg-gray-700 flex items-center justify-center h-full w-full">
                <p class="text-gray-400">Loading Map...</p>
            </div>
        </div>
        <!-- Public Sidebar -->
        <!-- SCROLL FIX: Removed h-[60vh] to allow natural height on mobile -->
        <div class="w-full md:w-1/3 md:h-full flex flex-col bg-gray-800 p-4 space-y-4 overflow-y-auto border-l-2 border-teal-600">
            <h1 class="text-2xl font-bold text-white pb-2 border-b border-gray-700">Live Job Tracking</h1>
            <div id="public-job-details" class="bg-gray-900 p-4 rounded-lg shadow-sm space-y-2 text-gray-300">
                <!-- Public job details will be rendered here -->
            </div>
        </div>
    </div>

    <!-- Public Driver View Container -->
    <!-- SCROLL FIX: Changed h-screen to md:h-screen to allow scrolling on mobile -->
    <div id="public-driver-container" class="hidden flex flex-col md:flex-row md:h-screen">
        <!-- SCROLL FIX: Changed h-[40vh] to h-96 for a fixed but scrollable height on mobile -->
        <div id="public-driver-map-container" class="w-full md:w-2/3 h-96 md:h-full">
            <div id="public-driver-map" class="rounded-lg shadow-md bg-gray-700 flex items-center justify-center h-full w-full">
                <p class="text-gray-400">Loading Map...</p>
            </div>
        </div>
        <!-- SCROLL FIX: Removed h-[60vh] to allow natural height on mobile -->
        <div class="w-full md:w-1/3 md:h-full flex flex-col bg-gray-800 p-4 space-y-4 overflow-y-auto border-l-2 border-indigo-600">
            <h1 class="text-2xl font-bold text-white pb-2 border-b border-gray-700">Live Driver Tracking</h1>
            <div id="public-driver-details" class="bg-gray-900 p-4 rounded-lg shadow-sm space-y-2 text-gray-300">
                <!-- Public driver details will be rendered here -->
            </div>
        </div>
    </div>

    <!-- Modals -->
    <div id="location-share-modal" class="hidden fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-[10001]">
        <div class="bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-md mx-4">
            <h3 class="text-xl font-bold text-white mb-4">Share My Location</h3>
            <p class="text-sm text-gray-400 mb-4">Share a temporary link to your live location. Set a destination to include ETA.</p>
            
            <div class="space-y-3">
                <input type="text" id="location-share-destination" placeholder="Enter a destination (optional)" class="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-lg text-white placeholder-gray-400">
                <div class="flex space-x-2">
                    <button id="set-personal-route-btn" class="w-full px-4 py-2 bg-teal-600 text-white rounded-lg hover:bg-teal-700">Set Route</button>
                    <button id="clear-personal-route-btn" class="hidden w-full px-4 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700">Clear Route</button>
                </div>
                <div id="personal-route-info" class="text-sm text-gray-300 hidden">
                    <p><strong>ETA:</strong> <span id="personal-route-eta">--</span></p>
                    <p><strong>Distance:</strong> <span id="personal-route-distance">--</span></p>
                </div>
            </div>

            <div id="location-share-details" class="mt-4 pt-4 border-t border-gray-600 space-y-4">
                <div>
                    <label for="location-share-mobile" class="block text-sm font-medium text-gray-300">Send to Mobile:</label>
                    <div class="flex space-x-2 mt-1">
                        <input type="tel" id="location-share-mobile" placeholder="Enter mobile number" class="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-lg text-white placeholder-gray-400">
                        <button type="button" id="send-location-sms-btn" class="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 flex-shrink-0">Send</button>
                    </div>
                </div>
                <div class="flex space-x-2">
                    <input type="text" id="location-share-url" readonly class="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-lg text-white">
                    <button id="copy-location-share-btn" class="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700">Copy</button>
                </div>
                <div class="text-center">
                    <p class="text-gray-400 mb-2">Or scan QR Code</p>
                    <div id="location-share-qrcode" class="flex justify-center p-2 bg-white rounded-lg w-36 h-36 mx-auto"></div>
                </div>
            </div>
            <button id="location-share-close-btn" class="mt-6 w-full px-4 py-2 bg-gray-600 text-white rounded-lg hover:bg-gray-500">Close</button>
        </div>
    </div>
    <div id="company-modal" class="hidden fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-[10004]">
        <div class="bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-md mx-4">
            <h3 class="text-xl font-bold text-white mb-6">Select or Create Company</h3>
            <div class="space-y-4">
                <div>
                    <h4 class="text-lg font-semibold text-gray-200 mb-2">Join Existing Company</h4>
                    <ul id="company-list" class="space-y-2 max-h-48 overflow-y-auto">
                        <!-- Company list will be populated here -->
                    </ul>
                </div>
                <div class="border-t border-gray-700 pt-4">
                    <h4 class="text-lg font-semibold text-gray-200 mb-2">Create New Company</h4>
                    <form id="create-company-form" class="space-y-2">
                        <input type="text" id="new-company-name" placeholder="Company Name" required class="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-lg text-white placeholder-gray-400">
                        <input type="password" id="new-company-password" placeholder="Company Password (optional)" class="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-lg text-white placeholder-gray-400">
                        <button type="submit" class="w-full px-4 py-2 bg-teal-600 text-white rounded-lg hover:bg-teal-700">Create & Join</button>
                    </form>
                </div>
            </div>
            <button id="company-cancel-btn" class="mt-8 w-full px-4 py-2 bg-gray-600 text-white rounded-lg hover:bg-gray-700">Close</button>
        </div>
    </div>

    <div id="company-password-modal" class="hidden fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-[10005]">
        <div class="bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-sm mx-4">
            <form id="company-password-form">
                <h3 id="company-password-title" class="text-xl font-bold text-white mb-4">Enter Password</h3>
                <input type="password" id="company-password-input" placeholder="Company Password" required class="w-full px-4 py-2 bg-gray-700 border border-gray-600 rounded-lg text-white placeholder-gray-400">
                <div class="flex justify-end space-x-2 mt-6">
                    <button type="button" id="company-password-cancel-btn" class="px-4 py-2 bg-gray-600 text-white rounded-lg hover:bg-gray-700">Cancel</button>
                    <button type="submit" class="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700">Join</button>
                </div>
            </form>
        </div>
    </div>

    <div id="invite-modal" class="hidden fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-[10004]">
        <div class="bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-md mx-4">
            <h3 class="text-xl font-bold text-white mb-6">Invite Others to your Company</h3>
            <div class="space-y-6">
                <!-- QR Code Section -->
                <div class="text-center">
                    <p class="text-gray-400 mb-2">Scan QR Code</p>
                    <div id="qrcode" class="flex justify-center p-2 bg-white rounded-lg"></div>
                </div>
                <!-- Share Link Section -->
                <div>
                    <p class="text-gray-400 mb-2">Or share this link:</p>
                    <div class="flex space-x-2">
                        <input type="text" id="share-link-input" readonly class="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-lg text-white">
                        <button id="copy-link-btn" class="px-4 py-2 bg-teal-600 text-white rounded-lg hover:bg-teal-700">Copy</button>
                    </div>
                </div>
                <!-- Email Invite Section -->
                <div>
                    <p class="text-gray-400 mb-2">Or send an email invite:</p>
                    <form id="email-invite-form" class="flex space-x-2">
                        <input type="email" id="email-invite-input" placeholder="Enter email address" required class="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-lg text-white placeholder-gray-400">
                        <button type="submit" class="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700">Send</button>
                    </form>
                </div>
            </div>
            <button id="invite-cancel-btn" class="mt-8 w-full px-4 py-2 bg-gray-600 text-white rounded-lg hover:bg-gray-700">Close</button>
        </div>
    </div>
    <div id="user-guide-modal" class="hidden fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-[10004]">
        <div class="bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-2xl mx-4 flex flex-col" style="max-height: 90vh;">
            <h3 class="text-2xl font-bold text-white mb-4">Vecto</h3>
            <div class="overflow-y-auto text-gray-300 space-y-4">
                <p>Welcome to Vecto! This guide will walk you through all the features of the app, whether you're a dispatcher managing the fleet or a driver on the road.</p>
                <div>
                    <h4 class="text-lg font-semibold text-teal-400">1. Getting Started: Your First Login</h4>
                    <p>Before you can use the app, you'll need to sign in and join your company.</p>
                    <ol class="list-decimal list-inside space-y-2 mt-2">
                        <li><strong>Sign In:</strong> On the main screen, click the <strong>"Sign in with Google"</strong> button to securely log in with your Google account.</li>
                        <li><strong>Allow Location:</strong> Your browser will ask for permission to share your location. Please click <strong>"Allow"</strong>. This is essential for the map and live tracking features to work.</li>
                        <li><strong>Join or Create a Company:</strong>
                            <ul class="list-disc list-inside ml-4">
                                <li><strong>To Join:</strong> A modal will appear with a list of existing companies. Find your company in the list and click <strong>"Join"</strong>. If it's password-protected, you'll be prompted to enter it.</li>
                                <li><strong>To Create:</strong> If you are the first person from your organization, you can create a new company. Type in your company's name, set an optional password for others to join, and click <strong>"Create & Join"</strong>. The creator automatically becomes an administrator.</li>
                            </ul>
                        </li>
                        <li><strong>Set Your Name:</strong> After joining a company, click the <strong>Settings icon (⚙️)</strong> in the top right, select <strong>"Edit Profile"</strong>, and enter the name you want displayed to your team.</li>
                    </ol>
                </div>
                <div>
                    <h4 class="text-lg font-semibold text-teal-400">2. The Two Views: Dispatcher vs. Driver</h4>
                    <p>Route Tracker has two main roles, which are set by a company administrator. Your view of the app will change based on your role.</p>
                    <ul class="list-disc list-inside space-y-2 mt-2">
                        <li><strong>Dispatcher View (Admin):</strong> This is the command center. You can see all jobs (current and archived), the real-time location of all active drivers, and have access to management actions like creating jobs and managing user roles.</li>
                        <li><strong>Driver View:</strong> This is the streamlined, on-the-road view. You will only see your currently assigned job and a list of open jobs available for you to claim.</li>
                    </ul>
                </div>
                <div>
                    <h4 class="text-lg font-semibold text-teal-400">3. For Dispatchers: Managing Operations</h4>
                    <p>As a dispatcher, your sidebar is your main dashboard.</p>
                    <ul class="list-disc list-inside space-y-2 mt-2">
                        <li><strong>Creating a Job:</strong>
                            <ol class="list-decimal list-inside ml-4">
                                <li>Click the green <strong>"Create Job"</strong> button.</li>
                                <li>Fill in the job details: a name, the starting point, and at least one destination. Use the <strong>"Add Destination"</strong> button for multi-stop routes.</li>
                                <li>If you have more than one destination, you can check the <strong>"Optimize Route"</strong> box to have Google Maps calculate the most efficient order of stops.</li>
                                <li>Optionally, add customer contact info and any special notes for the driver.</li>
                                <li>You can either <strong>assign the job directly</strong> to an available driver from the dropdown menu or leave it unassigned to post it as an open job for any driver to claim.</li>
                            </ol>
                        </li>
                        <li><strong>Tracking & Managing Jobs:</strong>
                            <ul class="list-disc list-inside ml-4">
                                <li><strong>The Map:</strong> The main map shows you the real-time location of all your active drivers. In-progress job routes are drawn on the map, color-coded for clarity.</li>
                                <li><strong>The Dashboard:</strong>
                                    <ul class="list-disc list-inside ml-4">
                                        <li>Use the <strong>"Current"</strong> and <strong>"Archive"</strong> tabs to switch between active and completed jobs.</li>
                                        <li>The <strong>"Drivers"</strong> list shows all currently online drivers, their status (Available, On Break, On Trip), and their contact info.</li>
                                    </ul>
                                </li>
                                <li><strong>Job Details:</strong> Click on any job card in the list to open a detailed view. Here you can:
                                    <ul class="list-disc list-inside ml-4">
                                        <li>Review all job information.</li>
                                        <li>Read and send messages in the job-specific chat.</li>
                                        <li>Create a <strong>Public Tracking Link</strong> to share with customers.</li>
                                        <li><strong>Cancel</strong> the job if needed.</li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                        <li><strong>Completing a Job:</strong>
                            <ol class="list-decimal list-inside ml-4">
                                <li>When a driver marks a job as complete, its card will turn green and move into a "pending-completion" state.</li>
                                <li>Click the card to review the driver's completion comments and any photos they uploaded.</li>
                                <li>Click the <strong>"Finalize"</strong> button, add your own closing comments if needed, and the job will be moved to the archive.</li>
                            </ol>
                        </li>
                    </ul>
                </div>
                <div>
                    <h4 class="text-lg font-semibold text-teal-400">4. For Drivers: On the Road</h4>
                    <p>As a driver, your view is focused on the task at hand.</p>
                     <ul class="list-disc list-inside space-y-2 mt-2">
                        <li><strong>Finding & Accepting a Job:</strong>
                            <ul class="list-disc list-inside ml-4">
                                <li>The <strong>"Open Job Postings"</strong> panel shows all unassigned jobs.</li>
                                <li>Click on a job to view its details. If you want to take it, click the <strong>"Accept Job"</strong> button.</li>
                            </ul>
                        </li>
                        <li><strong>Your Current Job:</strong>
                            <ul class="list-disc list-inside ml-4">
                                <li>Once you accept a job, it appears in the <strong>"My Current Job"</strong> panel at the top.</li>
                                <li>From here, you can:
                                    <ul class="list-disc list-inside ml-4">
                                        <li><strong>Navigate:</strong> Opens Google Maps with the route pre-filled for turn-by-turn directions.</li>
                                        <li><strong>Complete:</strong> When you have finished the job, click this. You'll be prompted to add a completion comment and can optionally upload a photo (e.g., for proof of delivery).</li>
                                    </ul>
                                </li>
                                <li>Clicking anywhere on the panel will open the full job details view, where you can also access the message chat with dispatch.</li>
                            </ul>
                        </li>
                        <li><strong>Your Status:</strong>
                            <ul class="list-disc list-inside ml-4">
                                <li>Use the <strong>"My Status"</strong> dropdown to set your availability. Set it to <strong>"Available"</strong> when you are ready for a job, and <strong>"On Break"</strong> when you are not. Your status is automatically set to "On Trip" when you accept a job.</li>
                            </ul>
                        </li>
                    </ul>
                </div>
                 <div>
                    <h4 class="text-lg font-semibold text-teal-400">5. Key Features for Everyone</h4>
                     <ul class="list-disc list-inside space-y-2 mt-2">
                        <li><strong>Messaging:</strong> Every job has its own private chat log. When a new message arrives in a job you're viewing, the job card in the list will have a <strong>pulsing border</strong> to notify you.</li>
                        <li><strong>Settings & Admin Controls:</strong>
                            <ul class="list-disc list-inside ml-4">
                                <li>The <strong>Settings icon (⚙️)</strong> gives you access to edit your profile, invite new users to your company, and view this user guide.</li>
                                <li>If you are an administrator, you will also see an <strong>"Admin: User Roles"</strong> button. This allows you to manage the permissions for every user in your company, promoting them to dispatchers or changing their roles as needed.</li>
                            </ul>
                        </li>
                    </ul>
                </div>
            </div>
            <div class="mt-6 pt-4 border-t border-gray-700 flex justify-end">
                <button id="user-guide-close-btn" class="px-6 py-2 bg-gray-600 text-white rounded-lg hover:bg-gray-500">Close</button>
            </div>
        </div>
    </div>
    <div id="comment-modal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-[10003]">
        <div class="bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-md mx-4">
            <form id="comment-form">
                <h3 id="comment-modal-title" class="text-xl font-bold text-white mb-4">Add Comment</h3>
                <textarea id="comment-input" placeholder="Enter your comment..." rows="4" required class="w-full px-4 py-2 bg-gray-700 border border-gray-600 rounded-lg text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-blue-500"></textarea>
                <div class="mt-4">
                    <label for="pod-upload" class="block text-sm font-medium text-gray-300">Add Photo (Proof of Delivery)</label>
                    <input type="file" id="pod-upload" accept="image/*" class="mt-1 block w-full text-sm text-gray-400 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-teal-50 file:text-teal-700 hover:file:bg-teal-100"/>
                </div>
                <div class="flex justify-end space-x-2 mt-6">
                    <button type="button" id="comment-cancel-btn" class="px-4 py-2 bg-gray-600 text-white rounded-lg hover:bg-gray-700">Cancel</button>
                    <button type="submit" class="px-4 py-2 bg-teal-600 text-white rounded-lg hover:bg-teal-700">Submit</button>
                </div>
            </form>
        </div>
    </div>
    <div id="profile-modal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
        <div class="bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-sm mx-4">
            <form id="profile-form">
                <h3 class="text-xl font-bold text-white mb-4">Edit Profile</h3>
                <div class="space-y-4">
                    <input type="text" id="profile-name-input" placeholder="Your Name" required class="w-full px-4 py-2 bg-gray-700 border border-gray-600 rounded-lg text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-blue-500">
                    <input type="tel" id="profile-phone-input" placeholder="Mobile Number" class="w-full px-4 py-2 bg-gray-700 border border-gray-600 rounded-lg text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-blue-500">
                </div>
                <div class="flex justify-end space-x-2 mt-6">
                    <button type="button" id="profile-cancel-btn" class="px-4 py-2 bg-gray-600 text-white rounded-lg hover:bg-gray-700">Cancel</button>
                    <button type="submit" class="px-4 py-2 bg-teal-600 text-white rounded-lg hover:bg-teal-700">Save</button>
                </div>
            </form>
        </div>
    </div>
    <div id="create-job-modal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
        <div class="bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-lg mx-4">
            <form id="create-job-form">
                <h3 id="create-job-modal-title" class="text-xl font-bold text-white mb-4">Create New Job</h3>
                <input type="hidden" id="editing-job-id">
                <div class="space-y-4">
                    <input type="text" id="job-name-input" placeholder="Job Name (e.g., Warehouse Delivery)" required class="w-full px-4 py-2 bg-gray-700 border border-gray-600 rounded-lg text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-blue-500">
                    <div>
                        <label for="job-date-input" class="block text-sm font-medium text-gray-300">Job Date:</label>
                        <input type="date" id="job-date-input" required class="w-full mt-1 px-4 py-2 bg-gray-700 border border-gray-600 rounded-lg text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-blue-500">
                    </div>
                    <input type="text" id="job-origin-input" placeholder="Job Origin" required class="w-full px-4 py-2 bg-gray-700 border border-gray-600 rounded-lg text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-blue-500">
                    
                    <hr class="my-4 border-gray-600">

                    <div id="destinations-container" class="space-y-2">
                        <!-- Dynamic destination fields will be added here -->
                    </div>
                    <button type="button" id="add-destination-btn" class="w-full px-4 py-2 bg-gray-600 text-white rounded-lg hover:bg-gray-700 text-sm">Add Destination</button>
                    
                    <div id="optimize-route-container" class="hidden items-center">
                        <input id="optimize-route-checkbox" type="checkbox" class="h-4 w-4 text-teal-600 bg-gray-700 border-gray-600 rounded focus:ring-teal-500">
                        <label for="optimize-route-checkbox" class="ml-2 block text-sm text-gray-300">Optimize Route</label>
                    </div>

                    <input type="text" id="contact-name-input" placeholder="Contact Name" class="w-full px-4 py-2 bg-gray-700 border border-gray-600 rounded-lg text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-blue-500">
                    <input type="tel" id="contact-number-input" placeholder="Contact Number" class="w-full px-4 py-2 bg-gray-700 border border-gray-600 rounded-lg text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-blue-500">
                    <textarea id="job-note-input" placeholder="Job Notes (optional)" rows="2" class="w-full px-4 py-2 bg-gray-700 border border-gray-600 rounded-lg text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-blue-500"></textarea>
                    <div>
                        <label for="drivers-needed-input" class="block text-sm font-medium text-gray-300">Number of Drivers Needed:</label>
                        <input type="number" id="drivers-needed-input" min="1" max="9" value="1" required class="w-full mt-1 px-4 py-2 bg-gray-700 border border-gray-600 rounded-lg text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-blue-500">
                    </div>
                     <div>
                        <label for="assign-driver-select" class="block text-sm font-medium text-gray-300">Assign Driver (optional):</label>
                        <select id="assign-driver-select" class="w-full mt-1 px-4 py-2 bg-gray-700 border border-gray-600 rounded-lg text-white focus:outline-none focus:ring-2 focus:ring-blue-500">
                            <option value="">Post as open job</option>
                        </select>
                    </div>
                    <div class="flex justify-end space-x-2">
                        <button type="button" id="create-job-cancel-btn" class="px-4 py-2 bg-gray-600 text-white rounded-lg hover:bg-gray-700">Cancel</button>
                        <button type="submit" id="create-job-submit-btn" class="px-4 py-2 bg-teal-600 text-white rounded-lg hover:bg-teal-700 flex items-center justify-center w-32">
                            <span class="btn-text">Add</span>
                            <span class="spinner hidden ml-2"></span>
                        </button>
                    </div>
                </div>
            </form>
        </div>
    </div>
    <div id="confirm-modal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-[10002]">
        <div class="bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-sm mx-4">
            <h3 id="confirm-modal-title" class="text-xl font-bold text-white mb-4">Are you sure?</h3>
            <p id="confirm-modal-message" class="text-gray-300 mb-4"></p>
            <div class="flex justify-end space-x-2">
                <button id="confirm-cancel-btn" class="px-4 py-2 bg-gray-600 text-white rounded-lg hover:bg-gray-700">Cancel</button>
                <button id="confirm-action-btn" class="px-4 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700">Confirm</button>
            </div>
        </div>
    </div>
    <div id="job-details-modal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-[10000]">
        <div class="bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-lg mx-4 flex flex-col" style="max-height: 90vh;">
            <div id="job-details-printable" class="overflow-y-auto flex-grow">
                <div class="flex justify-between items-center mb-4">
                    <h3 class="text-2xl font-bold text-white">Job Details</h3>
                </div>
                <div id="job-details-content" class="text-gray-300 space-y-2"></div>
                <div id="pod-section" class="mt-4 hidden">
                    <h4 class="text-lg font-semibold text-white mb-2">Proof of Delivery</h4>
                    <img id="pod-image" src="" alt="Proof of Delivery" class="rounded-lg max-w-full h-auto">
                </div>
                <div id="driver-completion-comment-section" class="mt-4 hidden">
                    <h4 class="text-lg font-semibold text-white mb-2">Driver's Completion Comment</h4>
                    <p id="driver-completion-comment" class="text-sm text-gray-400 italic p-2 border border-gray-700 rounded-md"></p>
                </div>
                <div id="dispatcher-closing-comment-section" class="mt-4 hidden">
                    <h4 class="text-lg font-semibold text-white mb-2">Dispatcher's Closing Comment</h4>
                    <p id="dispatcher-closing-comment" class="text-sm text-gray-400 italic p-2 border border-gray-700 rounded-md"></p>
                </div>
                <div class="mt-4">
                    <h4 class="text-lg font-semibold text-white mb-2">Job History</h4>
                    <ul id="job-history-log" class="space-y-1 text-sm text-gray-400"></ul>
                </div>
                <div id="tracking-link-section" class="mt-4 pt-4 border-t border-gray-700">
                    <h4 class="text-lg font-semibold text-white mb-2">Tracking Link</h4>
                    <div id="tracking-link-container">
                        <!-- Button will be dynamically inserted here -->
                    </div>
                </div>
                 <div class="mt-4">
                    <h4 class="text-lg font-semibold text-white mb-2">Messages</h4>
                    <div id="job-chat-box" class="h-40 border border-gray-700 rounded-md p-2 overflow-y-auto"></div>
                    <form id="job-chat-form" class="mt-2 flex space-x-2">
                        <input type="text" id="job-chat-input" placeholder="Type a message..." class="flex-grow px-3 py-2 bg-gray-700 border border-gray-600 rounded-lg text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-blue-500">
                        <button type="submit" class="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700">Send</button>
                    </form>
                </div>
                <!-- Creator ID Tag for Print -->
                <div class="creator-tag-print pt-4 mt-4 border-t border-gray-300 text-center text-xs font-thin">
                    <p>Vecto</p>
                    <p>Wolfe.BT@TangentLLC</p>
                </div>
            </div>
            <div id="job-details-driver-actions" class="hidden mt-4">
                <button id="job-details-accept-btn" class="w-full px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700">Accept Job</button>
            </div>
            <div class="mt-6 pt-4 border-t border-gray-700 flex justify-between items-center flex-shrink-0 space-x-2">
                <div class="flex-grow flex justify-end space-x-2">
                    <!-- FINALIZE JOB FIX: Added Finalize Job button for dispatchers -->
                    <button id="finalize-job-btn" class="hidden px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700">Finalize Job</button>
                    <button id="edit-job-btn" class="hidden px-4 py-2 bg-yellow-600 text-white rounded-lg hover:bg-yellow-700">Edit</button>
                    <button id="archive-job-btn" class="hidden px-4 py-2 bg-gray-500 text-white rounded-lg hover:bg-gray-600">Archive</button>
                    <button id="unarchive-job-modal-btn" class="hidden px-4 py-2 bg-gray-500 text-white rounded-lg hover:bg-gray-600">Unarchive</button>
                    <button id="print-job-btn" class="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700">Print</button>
                    <button id="delete-job-btn" class="hidden px-4 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700">Delete</button>
                    <button id="job-details-driver-cancel-btn" class="hidden px-4 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700">Cancel Assignment</button>
                    <button id="job-details-close-btn" class="px-6 py-2 bg-gray-600 text-white rounded-lg hover:bg-gray-500">Close</button>
                </div>
            </div>
        </div>
    </div>
    <div id="tracking-link-modal" class="hidden fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-[10001]">
        <div class="bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-md mx-4">
            <h3 class="text-xl font-bold text-white mb-4">Tracking Link</h3>
            
            <!-- Form to generate the link -->
            <form id="tracking-link-form" class="space-y-4">
                <p class="text-sm text-gray-400">Create a real-time tracking link to share with a third party.</p>
                <button type="submit" id="generate-tracking-link-btn" class="w-full px-4 py-2 bg-teal-600 text-white rounded-lg hover:bg-teal-700">Generate Link</button>
            </form>
    
            <!-- Details of the generated link -->
            <div id="tracking-link-details" class="hidden mt-4 space-y-4">
                <div>
                    <label for="tracking-link-mobile" class="block text-sm font-medium text-gray-300">Send to Mobile:</label>
                    <div class="flex space-x-2 mt-1">
                        <input type="tel" id="tracking-link-mobile" placeholder="Enter mobile number" class="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-lg text-white placeholder-gray-400">
                        <button type="button" id="send-sms-btn" class="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 flex-shrink-0">Send</button>
                    </div>
                </div>
                <div class="flex space-x-2">
                    <input type="text" id="tracking-link-url" readonly class="w-full px-3 py-2 bg-gray-700 border border-gray-600 rounded-lg text-white">
                    <button id="copy-tracking-link-btn" class="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700">Copy</button>
                </div>
                <div class="text-center">
                    <p class="text-gray-400 mb-2">Or scan QR Code</p>
                    <div id="tracking-link-qrcode" class="flex justify-center p-2 bg-white rounded-lg w-36 h-36 mx-auto"></div>
                </div>
            </div>
            <button id="tracking-link-close-btn" class="mt-6 w-full px-4 py-2 bg-gray-600 text-white rounded-lg hover:bg-gray-500">Close</button>
        </div>
    </div>
    <div id="admin-settings-modal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
        <div class="bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-md mx-4 overflow-y-auto" style="max-height: 90vh;">
            <div class="flex justify-between items-center mb-4">
                <h3 class="text-xl font-bold text-white">User Role Management</h3>
                <button id="refresh-user-roles-btn" class="p-1 rounded-full hover:bg-gray-700" title="Refresh List">
                    <svg class="w-5 h-5 text-gray-300" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17.65 6.35C16.2 4.9 14.21 4 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z"></path></svg>
                </button>
            </div>
            <div id="settings-content" class="space-y-4">
                 <ul id="user-role-list" class="space-y-4">
                     <!-- User roles will be dynamically inserted here -->
                 </ul>
            </div>
             <button id="admin-settings-cancel-btn" class="mt-6 w-full px-4 py-2 bg-gray-600 text-white rounded-lg hover:bg-gray-700">Close</button>
        </div>
    </div>
    <div id="settings-modal" class="hidden fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
        <div class="bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-md mx-4">
            <h3 class="text-xl font-bold text-white mb-6">Settings</h3>
            <div class="space-y-4">
                <button id="open-profile-modal-btn" class="w-full px-4 py-2 bg-gray-700 text-white rounded-lg hover:bg-gray-600">Edit Profile</button>
                <button id="open-user-guide-btn" class="w-full px-4 py-2 bg-gray-700 text-white rounded-lg hover:bg-gray-600">User Guide</button>
                <button id="open-invite-modal-btn" class="w-full px-4 py-2 bg-teal-600 text-white rounded-lg hover:bg-teal-700">Invite Others</button>
                <div id="admin-controls" class="hidden pt-4 border-t border-gray-700">
                     <button id="open-admin-settings-btn" class="w-full px-4 py-2 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700">Admin: User Roles</button>
                </div>
                <div class="pt-4 border-t border-gray-700 space-y-4">
                    <div>
                        <label for="google-maps-api-key-input" class="block text-sm font-medium text-gray-300">Google Maps API Key</label>
                        <input type="text" id="google-maps-api-key-input" placeholder="Enter your API key" class="w-full mt-1 px-4 py-2 bg-gray-700 border border-gray-600 rounded-lg text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-blue-500">
                        <button id="save-api-key-btn" class="w-full mt-2 px-4 py-2 bg-teal-600 text-white rounded-lg hover:bg-teal-700">Save Key</button>
                    </div>
                </div>
            </div>
            <button id="settings-cancel-btn" class="mt-6 w-full px-4 py-2 bg-gray-600 text-white rounded-lg hover:bg-gray-700">Close</button>
        </div>
    </div>

    <div id="geofence-modal" class="hidden fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-[10002]">
        <div class="bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-sm mx-4">
            <h3 class="text-xl font-bold text-white mb-4">Create Geofence</h3>
            <p class="text-gray-400 mb-4">Draw a polygon on the map to define the geofence area. Give it a name and save.</p>
            <input type="text" id="geofence-name-input" placeholder="Geofence Name (e.g., Warehouse)" class="w-full px-4 py-2 bg-gray-700 border border-gray-600 rounded-lg text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-blue-500">
            <div class="flex items-center mt-4">
                <input id="save-as-geofence-switch" type="checkbox" class="h-4 w-4 text-teal-600 bg-gray-700 border-gray-600 rounded focus:ring-teal-500">
                <label for="save-as-geofence-switch" class="ml-2 block text-sm text-gray-300">Save as Geofence</label>
            </div>
            <div class="flex justify-end space-x-2 mt-6">
                <button type="button" id="geofence-cancel-btn" class="px-4 py-2 bg-gray-600 text-white rounded-lg hover:bg-gray-700">Cancel</button>
                <button type="button" id="geofence-save-btn" class="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700">Save</button>
            </div>
        </div>
    </div>

    <div id="trail-modal" class="hidden fixed inset-0 bg-black bg-opacity-75 flex items-center justify-center z-[10002]">
        <div class="bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-sm mx-4">
            <h3 class="text-xl font-bold text-white mb-4">Save Trail</h3>
            <p class="text-gray-400 mb-4">Give your new trail a name.</p>
            <input type="text" id="trail-name-input" placeholder="Trail Name (e.g., North Ridge Trail)" class="w-full px-4 py-2 bg-gray-700 border border-gray-600 rounded-lg text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-blue-500">
            <div class="flex items-center mt-4">
                <input id="save-trail-as-geofence-switch" type="checkbox" class="h-4 w-4 text-teal-600 bg-gray-700 border-gray-600 rounded focus:ring-teal-500">
                <label for="save-trail-as-geofence-switch" class="ml-2 block text-sm text-gray-300">Save as Geofence</label>
            </div>
            <div class="flex justify-end space-x-2 mt-6">
                <button type="button" id="trail-cancel-btn" class="px-4 py-2 bg-gray-600 text-white rounded-lg hover:bg-gray-700">Cancel</button>
                <button type="button" id="trail-save-btn" class="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700">Save</button>
            </div>
        </div>
    </div>


    <!-- Firebase SDK Imports -->
    <script type="module">
        // --- Vecto - Vectorgraphic Map System ---
        // --- Wolfe.BT@TangentLLC ---
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, GoogleAuthProvider, signInWithPopup, signOut, onAuthStateChanged, signInWithCustomToken, signInAnonymously } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, doc, setDoc, onSnapshot, addDoc, serverTimestamp, GeoPoint, deleteDoc, query, where, getDocs, updateDoc, writeBatch, getDoc, arrayUnion, arrayRemove, runTransaction, enableIndexedDbPersistence, Timestamp, connectFirestoreEmulator } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { getStorage, ref, uploadBytes, getDownloadURL } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-storage.js";
        // --- Initialize Firebase and Services ---
        let app, auth, db, storage;
        let coreLibrary, mapsLibrary, placesLibrary, routesLibrary, markerLibrary, drawingLibrary, geometryLibrary;
        
        // --- UI Elements ---
        const loadingOverlay = document.getElementById('loading-overlay');
        const authContainer = document.getElementById('auth-container');
        const appContainer = document.getElementById('app-container');
        const googleSigninBtn = document.getElementById('google-signin-btn');
        const logoutBtn = document.getElementById('logout-btn');
        const settingsBtn = document.getElementById('settings-btn');
        const sidebarLoader = document.getElementById('sidebar-loader');
        const adminBadge = document.getElementById('admin-badge');
        const offlineBanner = document.getElementById('offline-banner');
        
        const driversListEl = document.getElementById('drivers-list');
        const refreshDriversBtn = document.getElementById('refresh-drivers-btn');
        const jobsListEl = document.getElementById('jobs-list');
        const jobDashboardPanel = document.getElementById('job-dashboard-panel');
        const jobSearchInput = document.getElementById('job-search-input');
        const dispatchUi = document.getElementById('dispatch-ui');
        const driverUi = document.getElementById('driver-ui');
        const userWelcomeEl = document.getElementById('user-welcome');
        const driverStatusPanel = document.getElementById('driver-status-panel');
        const driverStatusControl = document.getElementById('driver-status-control');
        const driverStatusSelect = document.getElementById('driver-status-select');
        const availableJobsPanel = document.getElementById('available-jobs-panel');
        const availableJobsList = document.getElementById('available-jobs-list');
        const managementActionsPanel = document.getElementById('management-actions-panel');
        
        // Company UI
        const companySelectionPanel = document.getElementById('company-selection-panel');
        const selectCompanyBtn = document.getElementById('select-company-btn');
        const selectCompanyBtnLabel = document.getElementById('select-company-btn-label');
        const companyModal = document.getElementById('company-modal');
        const companyListEl = document.getElementById('company-list');
        const createCompanyForm = document.getElementById('create-company-form');
        const newCompanyNameInput = document.getElementById('new-company-name');
        const newCompanyPasswordInput = document.getElementById('new-company-password');
        const companyCancelBtn = document.getElementById('company-cancel-btn');
        const companyPasswordModal = document.getElementById('company-password-modal');
        const companyPasswordForm = document.getElementById('company-password-form');
        const companyPasswordTitle = document.getElementById('company-password-title');
        const companyPasswordInput = document.getElementById('company-password-input');
        const companyPasswordCancelBtn = document.getElementById('company-password-cancel-btn');

        // Modals
        const inviteModal = document.getElementById('invite-modal');
        const openInviteModalBtn = document.getElementById('open-invite-modal-btn');
        const inviteCancelBtn = document.getElementById('invite-cancel-btn');
        const shareLinkInput = document.getElementById('share-link-input');
        const copyLinkBtn = document.getElementById('copy-link-btn');
        const emailInviteForm = document.getElementById('email-invite-form');
        const emailInviteInput = document.getElementById('email-invite-input');
        const qrcodeEl = document.getElementById('qrcode');

        const userGuideModal = document.getElementById('user-guide-modal');
        const openUserGuideBtn = document.getElementById('open-user-guide-btn');
        const userGuideCloseBtn = document.getElementById('user-guide-close-btn');

        const commentModal = document.getElementById('comment-modal');
        const commentForm = document.getElementById('comment-form');
        const commentModalTitle = document.getElementById('comment-modal-title');
        const commentInput = document.getElementById('comment-input');
        const podUploadInput = document.getElementById('pod-upload');
        const commentCancelBtn = document.getElementById('comment-cancel-btn');

        const profileModal = document.getElementById('profile-modal');
        const profileForm = document.getElementById('profile-form');
        const profileNameInput = document.getElementById('profile-name-input');
        const profilePhoneInput = document.getElementById('profile-phone-input');
        const profileCancelBtn = document.getElementById('profile-cancel-btn');
        
        const createJobModal = document.getElementById('create-job-modal');
        const openCreateJobModalBtn = document.getElementById('open-create-job-modal-btn');
        const createJobForm = document.getElementById('create-job-form');
        const createJobModalTitle = document.getElementById('create-job-modal-title');
        const editingJobIdInput = document.getElementById('editing-job-id');
        const jobNameInput = document.getElementById('job-name-input');
        const jobDateInput = document.getElementById('job-date-input');
        const jobOriginInput = document.getElementById('job-origin-input');
        const destinationsContainer = document.getElementById('destinations-container');
        const addDestinationBtn = document.getElementById('add-destination-btn');
        const optimizeRouteContainer = document.getElementById('optimize-route-container');
        const optimizeRouteCheckbox = document.getElementById('optimize-route-checkbox');
        const contactNameInput = document.getElementById('contact-name-input');
        const contactNumberInput = document.getElementById('contact-number-input');
        const jobNoteInput = document.getElementById('job-note-input');
        const driversNeededInput = document.getElementById('drivers-needed-input');
        const assignDriverSelect = document.getElementById('assign-driver-select');
        const createJobCancelBtn = document.getElementById('create-job-cancel-btn');

        const currentJobPanel = document.getElementById('current-job-panel');
        const currentJobDetails = document.getElementById('current-job-details');
        const completeJobBtn = document.getElementById('complete-job-btn');
        const startNavigationBtn = document.getElementById('start-navigation-btn');
        const arrivedBtn = document.getElementById('arrived-btn');

        const adminSettingsModal = document.getElementById('admin-settings-modal');
        const adminSettingsCancelBtn = document.getElementById('admin-settings-cancel-btn');
        const userRoleList = document.getElementById('user-role-list');
        const refreshUserRolesBtn = document.getElementById('refresh-user-roles-btn');
        
        const settingsModal = document.getElementById('settings-modal');
        const settingsCancelBtn = document.getElementById('settings-cancel-btn');
        const openProfileModalBtn = document.getElementById('open-profile-modal-btn');
        const adminControls = document.getElementById('admin-controls');
        const openAdminSettingsBtn = document.getElementById('open-admin-settings-btn');
        const googleMapsApiKeyInput = document.getElementById('google-maps-api-key-input');
        const saveApiKeyBtn = document.getElementById('save-api-key-btn');
        const firebaseConfigInput = document.getElementById('firebase-config-input');

        const confirmModal = document.getElementById('confirm-modal');
        const confirmModalTitle = document.getElementById('confirm-modal-title');
        const confirmModalMessage = document.getElementById('confirm-modal-message');
        const confirmCancelBtn = document.getElementById('confirm-cancel-btn');
        const confirmActionBtn = document.getElementById('confirm-action-btn');

        const jobDetailsModal = document.getElementById('job-details-modal');
        const jobDetailsContent = document.getElementById('job-details-content');
        const jobDetailsDriverActions = document.getElementById('job-details-driver-actions');
        const jobDetailsAcceptBtn = document.getElementById('job-details-accept-btn');
        const jobDetailsDriverCancelBtn = document.getElementById('job-details-driver-cancel-btn');
        const editJobBtn = document.getElementById('edit-job-btn');
        const archiveJobBtn = document.getElementById('archive-job-btn');
        const deleteJobBtn = document.getElementById('delete-job-btn');
        const unarchiveJobModalBtn = document.getElementById('unarchive-job-modal-btn');
        const finalizeJobBtn = document.getElementById('finalize-job-btn'); // FINALIZE JOB FIX: Get button element
        const podSection = document.getElementById('pod-section');
        const podImage = document.getElementById('pod-image');
        const driverCompletionCommentSection = document.getElementById('driver-completion-comment-section');
        const driverCompletionComment = document.getElementById('driver-completion-comment');
        const dispatcherClosingCommentSection = document.getElementById('dispatcher-closing-comment-section');
        const dispatcherClosingComment = document.getElementById('dispatcher-closing-comment');
        const jobHistoryLog = document.getElementById('job-history-log');
        const jobChatBox = document.getElementById('job-chat-box');
        const jobChatForm = document.getElementById('job-chat-form');
        const jobChatInput = document.getElementById('job-chat-input');
        const jobDetailsCloseBtn = document.getElementById('job-details-close-btn');
        const printJobBtn = document.getElementById('print-job-btn');

        // Tracking Link UI
        const trackingLinkSection = document.getElementById('tracking-link-section');
        const trackingLinkContainer = document.getElementById('tracking-link-container');
        const trackingLinkModal = document.getElementById('tracking-link-modal');
        const trackingLinkForm = document.getElementById('tracking-link-form');
        const trackingLinkMobileInput = document.getElementById('tracking-link-mobile');
        const sendSmsBtn = document.getElementById('send-sms-btn');
        const generateTrackingLinkBtn = document.getElementById('generate-tracking-link-btn');
        const trackingLinkDetails = document.getElementById('tracking-link-details');
        const trackingLinkUrlInput = document.getElementById('tracking-link-url');
        const copyTrackingLinkBtn = document.getElementById('copy-tracking-link-btn');
        const trackingLinkQrcodeEl = document.getElementById('tracking-link-qrcode');
        const trackingLinkCloseBtn = document.getElementById('tracking-link-close-btn');

        // Location Share UI
        const shareLocationBtn = document.getElementById('share-location-btn');
        const locationShareModal = document.getElementById('location-share-modal');
        const locationShareMobileInput = document.getElementById('location-share-mobile');
        const sendLocationSmsBtn = document.getElementById('send-location-sms-btn');
        const locationShareUrlInput = document.getElementById('location-share-url');
        const copyLocationShareBtn = document.getElementById('copy-location-share-btn');
        const locationShareQrcodeEl = document.getElementById('location-share-qrcode');
        const locationShareCloseBtn = document.getElementById('location-share-close-btn');
        const locationShareDestinationInput = document.getElementById('location-share-destination');
        const setPersonalRouteBtn = document.getElementById('set-personal-route-btn');
        const clearPersonalRouteBtn = document.getElementById('clear-personal-route-btn');
        const personalRouteInfo = document.getElementById('personal-route-info');
        const personalRouteEta = document.getElementById('personal-route-eta');
        const personalRouteDistance = document.getElementById('personal-route-distance');

        // Public View UI
        const publicJobContainer = document.getElementById('public-job-container');
        const publicMapEl = document.getElementById('public-map');
        const publicJobDetailsEl = document.getElementById('public-job-details');
        const publicDriverContainer = document.getElementById('public-driver-container');
        const publicDriverMapEl = document.getElementById('public-driver-map');
        const publicDriverDetailsEl = document.getElementById('public-driver-details');

        // Geofence UI
        const geofenceModal = document.getElementById('geofence-modal');
        const createGeofenceBtn = document.getElementById('create-geofence-btn');
        const geofenceCancelBtn = document.getElementById('geofence-cancel-btn');
        const geofenceSaveBtn = document.getElementById('geofence-save-btn');
        const geofenceNameInput = document.getElementById('geofence-name-input');
        const geofencesListEl = document.getElementById('geofences-list');
        const geofencePanel = document.getElementById('geofence-panel');

        // Trail Creation UI
        const walkingModeBtn = document.getElementById('walking-mode-btn');
        const trailCreationPanel = document.getElementById('trail-creation-panel');
        const startRecordingBtn = document.getElementById('start-recording-btn');
        const dropPointBtn = document.getElementById('drop-point-btn');
        const autoRecordContainer = document.getElementById('auto-record-container');
        const autoRecordSwitch = document.getElementById('auto-record-switch');
        const finishSaveBtn = document.getElementById('finish-save-btn');
        const savedTrailsPanel = document.getElementById('saved-trails-panel');
        const savedTrailsListEl = document.getElementById('saved-trails-list');
        const trailModal = document.getElementById('trail-modal');
        const trailNameInput = document.getElementById('trail-name-input');
        const trailCancelBtn = document.getElementById('trail-cancel-btn');
        const trailSaveBtn = document.getElementById('trail-save-btn');
        const trailNavigationContainer = document.getElementById('trail-navigation-container');
        const navigateToTrailBtn = document.getElementById('navigate-to-trail-btn');
        const navigateToStartBtn = document.getElementById('navigate-to-start-btn');


        // --- App State ---
        const AppState = {
            currentUser: null,
            isAuthReady: false, 
            companyId: null,
            companyName: null,
            map: null,
            publicMap: null,
            publicDriverMap: null,
            userMarker: null,
            driverMapMarkers: {},
            isSharingLocation: false,
            locationWatchId: null, 
            allUsers: [], 
            allJobs: [],
            activeDrivers: [],
            activeJobTab: 'current',
            isDispatchView: false,
            confirmCallback: null, 
            commentCallback: null,
            globalUsersPath: '',
            companiesPath: '',
            publicJobsPath: '',
            publicDriversPath: '',
            membersPath: '',
            driversPath: '',
            jobsPath: '',
            directionsService: null,
            jobRouteRenderers: {}, 
            personalRouteRenderer: null,
            jobColors: {}, 
            routeColors: ['#FF5733', '#33FF57', '#3357FF', '#FF33A1', '#A133FF', '#33FFA1', '#FFC300', '#C70039'],
            globalUnsubscribes: [],
            companyUnsubscribes: [],
            currentJobChatUnsubscribe: null,
            autocompleteInstances: [],
            passwordJoinCompanyId: null,
            currentJobIdForModal: null,
            drawingManager: null,
            currentPolygon: null,
            geofences: [],
            geofencePolygons: {},
            isRecording: false,
            currentTrail: null,
            lastRecordedPosition: null,
            navigationRenderer: null,
        };

        // --- Helper Functions ---
        function formatDuration(totalSeconds) {
            if (isNaN(totalSeconds) || totalSeconds < 0) {
                return 'N/A';
            }
            const days = Math.floor(totalSeconds / 86400);
            totalSeconds %= 86400;
            const hours = Math.floor(totalSeconds / 3600);
            totalSeconds %= 3600;
            const minutes = Math.floor(totalSeconds / 60);

            let result = '';
            if (days > 0) result += `${days}d `;
            if (hours > 0) result += `${hours}h `;
            if (minutes > 0 || (days === 0 && hours === 0)) result += `${minutes}m`;
            
            return result.trim();
        }
        
        function buildMarkerContent(name, color) {
            const markerDiv = document.createElement('div');
            markerDiv.style.width = '24px';
            markerDiv.style.height = '24px';
            markerDiv.style.borderRadius = '50%';
            markerDiv.style.backgroundColor = color;
            markerDiv.style.display = 'flex';
            markerDiv.style.justifyContent = 'center';
            markerDiv.style.alignItems = 'center';
            markerDiv.style.color = 'white';
            markerDiv.style.fontWeight = 'bold';
            markerDiv.style.fontSize = '12px';
            markerDiv.style.border = '2px solid white';
            markerDiv.style.boxShadow = '0 0 5px rgba(0,0,0,0.5)';
            markerDiv.textContent = name ? name.substring(0, 2).toUpperCase() : 'N/A';
            return markerDiv;
        }

        // --- Main App Initialization ---
        function initMap(elementId = "map") {
            const mapElement = document.getElementById(elementId);
            if (!mapsLibrary) {
                console.error("Google Maps script not loaded or API object not available.");
                if(mapElement) mapElement.innerHTML = `<div class="text-center p-4"><p class="font-bold text-red-400">Map Error</p><p class="text-gray-400">Could not load Google Maps.</p></div>`;
                return null;
            }
            if(mapElement) mapElement.innerHTML = ''; 
            const mapOptions = {
                center: { lat: 39.8283, lng: -98.5795 }, // Center of the US
                zoom: 4,
                disableDefaultUI: true,
                mapId: 'DEMO_MAP_ID', // REQUIRED for Advanced Markers. Styles are managed in Cloud Console.
            };
            const map = new mapsLibrary.Map(mapElement, mapOptions);
            
            if (elementId === 'public-map') AppState.publicMap = map;
            else if (elementId === 'public-driver-map') {
                AppState.publicDriverMap = map;
                AppState.personalRouteRenderer = new routesLibrary.DirectionsRenderer({
                    map: AppState.publicDriverMap, suppressMarkers: true, preserveViewport: false,
                    polylineOptions: { strokeColor: '#60a5fa', strokeWeight: 5, strokeOpacity: 0.8 },
                });
            }
            else AppState.map = map;
            
            return map;
        };

        async function initializeFirebase() {
            const firebaseConfig = {
              apiKey: "AIzaSyBGro7OUoAC1xXaBo8JjLnOQSFjZCmdoBI",
              authDomain: "route-tracker-e62b1.firebaseapp.com",
              projectId: "route-tracker-e62b1",
              storageBucket: "route-tracker-e62b1.firebasestorage.app",
              messagingSenderId: "1016000331711",
              appId: "1:1016000331711:web:a122b8a52045ee4e832b0a",
              measurementId: "G-B476Z21SKP"
            };

            const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';

            try {
                app = initializeApp(firebaseConfig);
                auth = getAuth(app);
                db = getFirestore(app);
                storage = getStorage(app);

                if (window.location.hostname === "127.0.0.1") {
                    connectFirestoreEmulator(db, '127.0.0.1', 8081);
                }

                await enableIndexedDbPersistence(db).catch(err => {
                    if (err.code == 'failed-precondition') console.warn("Firestore persistence failed.");
                    else if (err.code == 'unimplemented') console.warn("Firestore persistence not available.");
                });

                AppState.globalUsersPath = `/artifacts/${appId}/public/data/users`;
                AppState.companiesPath = `/artifacts/${appId}/public/data/companies`;
                AppState.publicJobsPath = `/artifacts/${appId}/public/data/publicJobs`;
                AppState.publicDriversPath = `/artifacts/${appId}/public/data/publicDrivers`;
                
                return true;
            } catch (e) {
                console.error("Critical Firebase initialization error:", e);
                loadingOverlay.innerHTML = `<p class="text-red-400">Critical Error: ${e.message}</p>`;
                return false;
            }
        }

        function startRegularAuthFlow() {
            let isInitialAuthCheck = true;
            onAuthStateChanged(auth, async (user) => {
                loadingOverlay.classList.add('hidden');
                if (user) {
                    isInitialAuthCheck = false;
                    if (navigator.geolocation) {
                        navigator.permissions.query({ name: 'geolocation' }).then(async (permissionStatus) => {
                            if (permissionStatus.state === 'granted') {
                                await setupUserSession(user);
                            } else if (permissionStatus.state === 'prompt') {
                                navigator.geolocation.getCurrentPosition(
                                    async () => { await setupUserSession(user); },
                                    () => {
                                        showToast("Geolocation is required for this app.", "error");
                                        cleanupUserSession();
                                    }
                                );
                            } else {
                                showToast("Geolocation is denied. Please enable it in browser settings.", "error");
                                cleanupUserSession();
                            }
                        }).catch(err => {
                            showToast("Could not check geolocation permissions.", "error");
                            console.error("Geolocation permission query error:", err);
                            cleanupUserSession();
                        });
                    } else {
                        showToast("Geolocation is not supported by your browser.", "error");
                        cleanupUserSession();
                    }
                } else { // User is null
                    if (isInitialAuthCheck) {
                        isInitialAuthCheck = false; // Prevent re-running auto-login
                        if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                            try { 
                                await signInWithCustomToken(auth, __initial_auth_token); 
                            } catch (error) {
                                console.error("Custom token sign-in failed, trying anonymous:", error);
                                await signInAnonymously(auth).catch(anonError => console.error("Anonymous sign-in also failed:", anonError));
                            }
                        } else {
                           try {
                                await signInAnonymously(auth);
                            } catch (anonError) {
                                console.error("Anonymous sign-in failed:", anonError);
                                showToast("Could not sign you in automatically.", "error");
                            }
                        }
                    } else {
                        // This block runs on explicit logout, after the initial check is done.
                        cleanupUserSession();
                    }
                }
            });
        }

        async function loadPublicDriverView(driverId, inviteId) {
            loadingOverlay.classList.add('hidden');
            authContainer.classList.add('hidden');
            appContainer.classList.add('hidden');
            publicDriverContainer.classList.remove('hidden');

            await loadGoogleMapsScript();
            initMap('public-driver-map');

            const publicDriverRef = doc(db, AppState.publicDriversPath, driverId);

            onSnapshot(publicDriverRef, (docSnap) => {
                if (docSnap.exists()) {
                    const driver = docSnap.data();
                    // Check if the link is valid and not expired
                    if (driver.shareToken !== inviteId || (driver.expiresAt && driver.expiresAt.toDate() < new Date())) {
                         publicDriverDetailsEl.innerHTML = `<p class="text-red-400">This tracking link is invalid or has expired.</p>`;
                         if (AppState.driverMapMarkers['publicDriver']) AppState.driverMapMarkers['publicDriver'].map = null;
                         if (AppState.personalRouteRenderer) AppState.personalRouteRenderer.setDirections({routes: []});
                         return;
                    }

                    let destinationHTML = driver.destination ? `<p><strong>Destination:</strong> ${driver.destination}</p>` : '';
                    let etaHTML = driver.eta ? `<p><strong>ETA:</strong> ${driver.eta}</p>` : '';
                    let distanceHTML = driver.distance ? `<p><strong>Distance:</strong> ${driver.distance}</p>` : '';

                    publicDriverDetailsEl.innerHTML = `
                        <p><strong>Driver:</strong> ${driver.name || 'N/A'}</p>
                        <p><strong>Mobile:</strong> ${driver.phone || 'N/A'}</p>
                        <p><strong>Status:</strong> ${driver.status || 'N/A'}</p>
                        ${destinationHTML}
                        ${etaHTML}
                        ${distanceHTML}
                        <p class="text-xs text-gray-400 mt-2">Last updated: ${driver.timestamp ? driver.timestamp.toDate().toLocaleString() : 'N/A'}</p>
                    `;

                    if (AppState.driverMapMarkers['publicDriver']) AppState.driverMapMarkers['publicDriver'].map = null;

                    if (driver.location) {
                        const driverPos = { lat: driver.location.latitude, lng: driver.location.longitude };
                        AppState.driverMapMarkers['publicDriver'] = new google.maps.marker.AdvancedMarkerElement({
                            position: driverPos,
                            map: AppState.publicDriverMap,
                            title: "Driver Location",
                            content: buildMarkerContent(driver.name, '#4285F4')
                        });
                        
                        if (driver.destination && AppState.directionsService) {
                            AppState.directionsService.route({
                                origin: driverPos,
                                destination: driver.destination,
                            travelMode: routesLibrary.TravelMode.DRIVING
                            }, (response, status) => {
                                if (status === 'OK') {
                                    AppState.personalRouteRenderer.setDirections(response);
                                } else {
                                    AppState.personalRouteRenderer.setDirections({routes: []});
                                }
                            });
                        } else {
                            AppState.personalRouteRenderer.setDirections({routes: []});
                            AppState.publicDriverMap.setCenter(driverPos);
                            AppState.publicDriverMap.setZoom(15);
                        }
                    }
                } else {
                    publicDriverDetailsEl.innerHTML = `<p class="text-red-400">This tracking link is invalid or has expired.</p>`;
                }
            });
        }

        async function loadPublicJobView(jobId, inviteId) {
            loadingOverlay.classList.add('hidden');
            authContainer.classList.add('hidden');
            appContainer.classList.add('hidden');
            publicJobContainer.classList.remove('hidden');

            await loadGoogleMapsScript();
            initMap('public-map');
            
            const publicJobRef = doc(db, AppState.publicJobsPath, jobId);
            
            onSnapshot(publicJobRef, (docSnap) => {
                if (docSnap.exists()) {
                    const job = docSnap.data();
                    
                    // Check if the link is valid and not expired
                    if (job.thirdPartyInviteId !== inviteId || (job.expiresAt && job.expiresAt.toDate() < new Date())) {
                        publicJobDetailsEl.innerHTML = `<p class="text-red-400">This tracking link is invalid or has expired.</p>`;
                         for (const key in AppState.driverMapMarkers) { AppState.driverMapMarkers[key].map = null; }
                         for (const key in AppState.jobRouteRenderers) { AppState.jobRouteRenderers[key].setMap(null); }
                        return;
                    }

                    let destinationsHTML = '';
                    if (job.destinations && job.destinations.length > 0) {
                        if (job.destinations.length > 1) {
                            destinationsHTML = `<p><strong>Route:</strong></p><ol class="list-decimal list-inside text-sm">${job.destinations.map(d => `<li>${d}</li>`).join('')}</ol>`;
                        } else {
                            destinationsHTML = `<p><strong>To:</strong> ${job.destinations[0]}</p>`;
                        }
                    } else {
                        destinationsHTML = `<p><strong>To:</strong> ${job.destination || 'N/A'}</p>`;
                    }

                    publicJobDetailsEl.innerHTML = `
                        <p><strong>Job:</strong> ${job.jobName || 'N/A'}</p>
                        <p><strong>Date:</strong> ${job.jobDate || 'N/A'}</p>
                        <p><strong>Status:</strong> ${job.status}</p>
                        <p><strong>From:</strong> ${job.origin}</p>
                        ${destinationsHTML}
                        <p><strong>Total Distance:</strong> ${job.totalDistance || 'N/A'}</p>
                        <p><strong>Est. Travel Time:</strong> ${formatDuration(job.totalDuration)}</p>
                        <hr class="my-2 border-gray-600">
                        <p><strong>Distance Remaining:</strong> <span id="public-job-distance">--</span></p>
                        <p><strong>ETA:</strong> <span id="public-job-eta">--</span></p>
                    `;
                    
                    for (const key in AppState.driverMapMarkers) {
                        AppState.driverMapMarkers[key].map = null;
                    }
                    AppState.driverMapMarkers = {};
                     for (const key in AppState.jobRouteRenderers) {
                        AppState.jobRouteRenderers[key].setMap(null);
                    }
                    AppState.jobRouteRenderers = {};

                    const finalDestination = job.destinations[job.destinations.length - 1];
                    const waypoints = job.destinations.slice(0, -1).map(d => ({ location: d, stopover: true }));

                    if (job.driverLocation) {
                        const driverPos = { lat: job.driverLocation.latitude, lng: job.driverLocation.longitude };
                        AppState.driverMapMarkers['publicDriver'] = new google.maps.marker.AdvancedMarkerElement({
                            position: driverPos,
                            map: AppState.publicMap,
                            title: "Driver Location",
                            content: buildMarkerContent('DR', '#4285F4')
                        });
                        
                         if (AppState.directionsService) {
                            const renderer = new routesLibrary.DirectionsRenderer({
                                map: AppState.publicMap, suppressMarkers: true, preserveViewport: false,
                                polylineOptions: { strokeColor: '#4285F4', strokeWeight: 5, strokeOpacity: 0.8 },
                            });
                            AppState.jobRouteRenderers['publicRoute'] = renderer;
                            AppState.directionsService.route({
                                origin: driverPos,
                                destination: finalDestination,
                                waypoints: waypoints,
                                travelMode: routesLibrary.TravelMode.DRIVING
                            }, (response, status) => {
                                if (status === 'OK') {
                                    renderer.setDirections(response);
                                    const leg = response.routes[0].legs[response.routes[0].legs.length - 1];
                                    document.getElementById('public-job-distance').textContent = leg.distance.text;
                                    document.getElementById('public-job-eta').textContent = leg.duration.text;
                                }
                            });
                         }
                    } else {
                         if (AppState.directionsService) {
                            const renderer = new routesLibrary.DirectionsRenderer({
                                map: AppState.publicMap, suppressMarkers: false, preserveViewport: false,
                                polylineOptions: { strokeColor: '#888888', strokeWeight: 5, strokeOpacity: 0.8 },
                            });
                            AppState.jobRouteRenderers['publicRoute'] = renderer;
                            AppState.directionsService.route({
                                origin: job.origin,
                                destination: finalDestination,
                                waypoints: waypoints,
                                travelMode: routesLibrary.TravelMode.DRIVING
                            }, (response, status) => {
                                if (status === 'OK') {
                                    renderer.setDirections(response);
                                }
                            });
                         }
                    }

                } else {
                    publicJobDetailsEl.innerHTML = `<p class="text-red-400">This tracking link is invalid or has expired.</p>`;
                }
            });
        }

        async function setupUserSession(user) {
            AppState.globalUnsubscribes.forEach(unsub => unsub());
            AppState.globalUnsubscribes = [];

            const userDocRef = doc(db, AppState.globalUsersPath, user.uid);
            
            const userUnsubscribe = onSnapshot(userDocRef, async (userDocSnap) => {
                let userData;
                if (!userDocSnap.exists()) {
                    userData = { 
                        email: user.email || user.uid, 
                        name: user.displayName || `User-${user.uid.substring(0, 4)}`,
                        phone: '',
                        currentCompanyId: null,
                    };
                    await setDoc(userDocRef, userData).catch(err => console.error("Error creating user profile:", err));
                } else {
                    userData = userDocSnap.data();
                }

                const companyChanged = AppState.currentUser?.currentCompanyId !== userData.currentCompanyId;
                AppState.currentUser = { id: user.uid, ...userData };
                AppState.isAuthReady = true; 
                
                authContainer.classList.add('hidden');
                appContainer.classList.remove('hidden');

                if (AppState.currentUser.currentCompanyId) {
                    if(companyChanged || !AppState.companyId) { 
                        await loadCompanyData(AppState.currentUser.currentCompanyId);
                    }
                } else {
                    cleanupCompanyState();
                    openCompanyModal();
                }

            }, (error) => {
                console.error("Error listening to user document:", error);
                showToast("Error loading your profile.", "error");
                AppState.isAuthReady = true; 
            });
            AppState.globalUnsubscribes.push(userUnsubscribe);
        }

        async function loadCompanyData(companyId) {
            if (!AppState.isAuthReady) return; 
            cleanupCompanyState();
            sidebarLoader.style.display = 'flex';
            
            AppState.companyId = companyId;
            const companyDocRef = doc(db, AppState.companiesPath, companyId);
            
            try {
                const companyDoc = await getDoc(companyDocRef);

                if (!companyDoc.exists()) {
                    showToast("Your assigned company could not be found. Please select a new one.", "error");
                    await updateDoc(doc(db, AppState.globalUsersPath, AppState.currentUser.id), { currentCompanyId: null });
                    sidebarLoader.style.display = 'none';
                    return;
                }

                const companyData = companyDoc.data();
                AppState.companyName = companyData.name;
                selectCompanyBtnLabel.textContent = AppState.companyName;

                const companyBasePath = `${AppState.companiesPath}/${companyId}`;
                AppState.membersPath = `${companyBasePath}/members`;
                AppState.driversPath = `${companyBasePath}/driverLocations`;
                AppState.jobsPath = `${companyBasePath}/jobs`;

                const memberDocRef = doc(db, AppState.membersPath, AppState.currentUser.id);
                const memberUnsubscribe = onSnapshot(memberDocRef, (memberDoc) => {
                    if (memberDoc.exists()) {
                        AppState.currentUser.permissions = memberDoc.data().permissions;
                        AppState.isDispatchView = checkPermission('canCreateJob');
                        renderUI();
                    }
                    sidebarLoader.style.display = 'none';
                }, (err) => { console.error("Error listening to member doc:", err); sidebarLoader.style.display = 'none'; });
                AppState.companyUnsubscribes.push(memberUnsubscribe);

                const membersUnsubscribe = onSnapshot(collection(db, AppState.membersPath), (snapshot) => {
                    AppState.allUsers = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                    renderUI();
                }, (err) => console.error("Error listening to members:", err));
                AppState.companyUnsubscribes.push(membersUnsubscribe);

                const driversUnsubscribe = onSnapshot(collection(db, AppState.driversPath), (snapshot) => {
                    AppState.activeDrivers = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                    renderUI();
                    renderMapObjects();
                }, (err) => console.error("Error listening to drivers:", err));
                AppState.companyUnsubscribes.push(driversUnsubscribe);

                const geofencesPath = `${companyBasePath}/geofences`;
                const geofencesUnsubscribe = onSnapshot(collection(db, geofencesPath), (snapshot) => {
                    AppState.geofences = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                    renderGeofencesList();
                    renderGeofencesOnMap();
                }, (err) => console.error("Error listening to geofences:", err));
                AppState.companyUnsubscribes.push(geofencesUnsubscribe);

                const trailsPath = `${companyBasePath}/trails`;
                const trailsUnsubscribe = onSnapshot(collection(db, trailsPath), (snapshot) => {
                    AppState.trails = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                    renderSavedTrailsList();
                }, (err) => console.error("Error listening to trails:", err));
                AppState.companyUnsubscribes.push(trailsUnsubscribe);
                
                setupJobListener();
            } catch (error) {
                console.error("Error loading company data:", error);
                showToast("Failed to load company data.", "error");
                sidebarLoader.style.display = 'none';
            }
        }

        function setupJobListener() {
            if (!AppState.companyId || !AppState.isAuthReady) return;
            const jobsRef = collection(db, AppState.jobsPath);
            const jobsUnsubscribe = onSnapshot(query(jobsRef), (snapshot) => {
                AppState.allJobs = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
                renderUI(); 
                renderMapObjects();
            }, (error) => {
                console.error("Error listening to jobs collection:", error);
                showToast("Could not load jobs.", "error");
            });
            AppState.companyUnsubscribes.push(jobsUnsubscribe);
        }

        function cleanupCompanyState() {
            AppState.companyUnsubscribes.forEach(unsub => unsub());
            AppState.companyUnsubscribes = [];
            AppState.companyId = null;
            AppState.companyName = null;
            selectCompanyBtnLabel.textContent = "Select/Change Company";
            AppState.allUsers = [];
            AppState.allJobs = [];
            AppState.activeDrivers = [];
            renderUI(); 
        }

        function cleanupUserSession() {
            stopAutomaticLocationSharing();
            AppState.globalUnsubscribes.forEach(unsub => unsub());
            AppState.globalUnsubscribes = [];
            cleanupCompanyState();
            AppState.currentUser = null;
            AppState.isAuthReady = false; 
            
            for (const jobId in AppState.jobRouteRenderers) {
                AppState.jobRouteRenderers[jobId].setMap(null);
            }
            AppState.jobRouteRenderers = {};
            for (const driverId in AppState.driverMapMarkers) {
                AppState.driverMapMarkers[driverId].map = null;
            }
            AppState.driverMapMarkers = {};
            if (AppState.userMarker) {
                AppState.userMarker.map = null;
                AppState.userMarker = null;
            }

            appContainer.classList.add('hidden');
            authContainer.classList.remove('hidden');
        }

        function checkPermission(permission) {
            return AppState.currentUser?.permissions?.[permission] === true;
        }
        
        function startAutomaticLocationSharing() {
            if (AppState.locationWatchId || !AppState.companyId || !navigator.geolocation) return;
            AppState.isSharingLocation = true;

            const options = {
                enableHighAccuracy: true,
                timeout: 10000,
                maximumAge: 0
            };

            const successCallback = (position) => {
                if (!AppState.companyId) return; 

                const newPos = { lat: position.coords.latitude, lng: position.coords.longitude };
                const myJob = AppState.allJobs.find(job => job.status === 'in-progress' && job.assignedDrivers.some(d => d.id === AppState.currentUser.id));
                const currentStatus = myJob ? 'On Trip' : driverStatusSelect.value;

                const locationData = {
                    location: new GeoPoint(newPos.lat, newPos.lng),
                    timestamp: serverTimestamp(),
                    status: currentStatus,
                    name: AppState.currentUser.name
                };
                setDoc(doc(db, AppState.driversPath, AppState.currentUser.id), locationData, { merge: true })
                    .catch(err => console.error("Error sharing location:", err));
                
                if (myJob && myJob.thirdPartyInviteId) {
                    const publicJobRef = doc(db, AppState.publicJobsPath, myJob.id);
                    updateDoc(publicJobRef, { driverLocation: locationData.location }).catch(err => console.log("Could not update public job location"));
                }
                
                const publicDriverRef = doc(db, AppState.publicDriversPath, AppState.currentUser.id);
                getDoc(publicDriverRef).then(docSnap => {
                    if (docSnap.exists()) {
                        const publicData = docSnap.data();
                        const updateData = {
                            location: locationData.location,
                            timestamp: locationData.timestamp,
                            status: locationData.status
                        };

                        if (publicData.destination && AppState.directionsService) {
                            AppState.directionsService.route({
                                origin: newPos,
                                destination: publicData.destination,
                                travelMode: routesLibrary.TravelMode.DRIVING
                            }, (response, status) => {
                                if (status === 'OK') {
                                    const leg = response.routes[0].legs[0];
                                    updateData.eta = leg.duration.text;
                                    updateData.distance = leg.distance.text;
                                }
                                updateDoc(publicDriverRef, updateData).catch(err => console.log("Could not update public driver location with route"));
                            });
                        } else {
                            updateDoc(publicDriverRef, updateData).catch(err => console.log("Could not update public driver location"));
                        }
                    }
                });

                checkGeofenceTransitions(AppState.currentUser.id, newPos);

                if (AppState.userMarker) {
                    AppState.userMarker.setPosition(newPos);
                }

                if (AppState.isRecording && autoRecordSwitch.checked) {
                    if (!AppState.lastRecordedPosition || geometryLibrary.spherical.computeDistanceBetween(new mapsLibrary.LatLng(AppState.lastRecordedPosition), newPos) > 10) {
                        const path = AppState.currentTrail.getPath();
                        path.push(newPos);
                        AppState.lastRecordedPosition = { lat: newPos.lat(), lng: newPos.lng() };
                    }
                }

                if (AppState.currentTrail && !AppState.isRecording) {
                    const isOutside = !geometryLibrary.poly.isLocationOnEdge(newPos, AppState.currentTrail, 0.0001);
                    trailNavigationContainer.classList.toggle('hidden', !isOutside);
                } else {
                    trailNavigationContainer.classList.add('hidden');
                }
            };

            navigateToStartBtn.addEventListener('click', () => {
                if (AppState.userMarker && AppState.currentTrail) {
                    const startPoint = AppState.currentTrail.getPath().getAt(0);
                    if (startPoint) {
                        AppState.directionsService.route({
                            origin: AppState.userMarker.getPosition(),
                            destination: startPoint,
                            travelMode: routesLibrary.TravelMode.WALKING
                        }, (response, status) => {
                            if (status === 'OK') {
                                if (!AppState.navigationRenderer) {
                                    AppState.navigationRenderer = new routesLibrary.DirectionsRenderer({
                                        map: AppState.map,
                                        suppressMarkers: true,
                                        polylineOptions: { strokeColor: '#00FF00', strokeWeight: 5, strokeOpacity: 0.8 },
                                    });
                                }
                                AppState.navigationRenderer.setDirections(response);
                            }
                        });
                    }
                }
            });

            navigateToTrailBtn.addEventListener('click', () => {
                if (AppState.userMarker && AppState.currentTrail) {
                    let nearestPoint = null;
                    let minDistance = Infinity;

                    const trailPath = AppState.currentTrail.getPath();
                    for (let i = 0; i < trailPath.getLength(); i++) {
                        const pointOnTrail = trailPath.getAt(i);
                        const distance = geometryLibrary.spherical.computeDistanceBetween(AppState.userMarker.getPosition(), pointOnTrail);
                        if (distance < minDistance) {
                            minDistance = distance;
                            nearestPoint = pointOnTrail;
                        }
                    }

                    if (nearestPoint) {
                        AppState.directionsService.route({
                            origin: AppState.userMarker.getPosition(),
                            destination: nearestPoint,
                            travelMode: routesLibrary.TravelMode.WALKING
                        }, (response, status) => {
                            if (status === 'OK') {
                                if (!AppState.navigationRenderer) {
                                    AppState.navigationRenderer = new routesLibrary.DirectionsRenderer({
                                        map: AppState.map,
                                        suppressMarkers: true,
                                        polylineOptions: { strokeColor: '#00FF00', strokeWeight: 5, strokeOpacity: 0.8 },
                                    });
                                }
                                AppState.navigationRenderer.setDirections(response);
                            }
                        });
                    }
                }
            });

            const errorCallback = (error) => {
                showToast(`Geolocation Error: ${error.message}`, "error");
                console.error("Geolocation watchPosition error:", error);
            };

            AppState.locationWatchId = navigator.geolocation.watchPosition(successCallback, errorCallback, options);
        }

        function stopAutomaticLocationSharing() {
            if (AppState.locationWatchId) {
                navigator.geolocation.clearWatch(AppState.locationWatchId);
                AppState.locationWatchId = null;
            }
            AppState.isSharingLocation = false;
            if (AppState.currentUser && AppState.companyId) {
                const driverLocRef = doc(db, AppState.driversPath, AppState.currentUser.id);
                deleteDoc(driverLocRef).catch(err => console.log("No location to delete or error:", err));
                
                const publicDriverRef = doc(db, AppState.publicDriversPath, AppState.currentUser.id);
                deleteDoc(publicDriverRef).catch(err => console.log("No public driver location to delete or error:", err));
            }
        }
        
        driverStatusSelect.addEventListener('change', () => {
            if (AppState.isSharingLocation && AppState.companyId) {
                const driverLocRef = doc(db, AppState.driversPath, AppState.currentUser.id);
                updateDoc(driverLocRef, { status: driverStatusSelect.value })
                    .catch(err => showToast("Could not update status.", "error"));
            }
        });
        
        function getJobColor(jobId) {
            if (!AppState.jobColors[jobId]) {
                const colorIndex = Object.keys(AppState.jobColors).length % AppState.routeColors.length;
                AppState.jobColors[jobId] = AppState.routeColors[colorIndex];
            }
            return AppState.jobColors[jobId];
        }

        function renderAllJobsList() {
            const isArchivedView = AppState.activeJobTab === 'archive';
            const searchTerm = jobSearchInput.value.toLowerCase();
            let jobsToRender = AppState.allJobs.filter(job => !!job.archived === isArchivedView);
            if (searchTerm) {
                jobsToRender = jobsToRender.filter(job => 
                    (job.jobName || '').toLowerCase().includes(searchTerm) ||
                    (job.origin || '').toLowerCase().includes(searchTerm) ||
                    (job.destinations && job.destinations.some(d => d.toLowerCase().includes(searchTerm)))
                );
            }
            jobsToRender.sort((a, b) => (b.createdAt?.toMillis() || 0) - (a.createdAt?.toMillis() || 0));
            jobsListEl.innerHTML = jobsToRender.length === 0 ? `<li class="text-gray-400 text-sm">No jobs found.</li>` : '';
            jobsToRender.forEach(job => {
                const li = document.createElement('li');
                li.dataset.jobId = job.id;
                const jobColor = getJobColor(job.id);
                
                let statusClass = 'bg-gray-800 hover:bg-gray-700';
                let borderColorClass = 'border-transparent';
                let statusTag = '';

                if (isArchivedView) {
                    statusTag = `<span class="text-xs font-semibold px-2 py-1 bg-gray-600 text-white rounded-full">Archived</span>`;
                } else if (job.status === 'pending-completion') {
                    statusClass = 'bg-green-900 hover:bg-green-800';
                    statusTag = `<span class="text-xs font-semibold px-2 py-1 bg-green-600 text-white rounded-full">Pending</span>`;
                } else if (job.status === 'in-progress') {
                    li.style.borderColor = jobColor;
                    statusTag = `<span class="text-xs font-semibold px-2 py-1 bg-blue-600 text-white rounded-full">In Progress</span>`;
                } else if (job.status === 'completed') {
                    borderColorClass = 'border-gray-600';
                    statusTag = `<span class="text-xs font-semibold px-2 py-1 bg-gray-600 text-white rounded-full">Completed</span>`;
                } else if (job.status === 'cancelled') {
                    statusTag = `<span class="text-xs font-semibold px-2 py-1 bg-red-600 text-white rounded-full">Cancelled</span>`;
                } else if (job.status === 'unassigned') {
                    statusTag = `<span class="text-xs font-semibold px-2 py-1 bg-yellow-600 text-white rounded-full">Available</span>`;
                }

                if (job.lastMessageTimestamp && AppState.currentUser && job.lastMessageTimestamp.toMillis() > (AppState.currentUser.lastRead?.[job.id] || 0)) {
                    li.classList.add('pulse-border');
                }

                li.className = `p-3 rounded-md text-sm cursor-pointer border-l-4 ${statusClass} ${borderColorClass}`;
                
                const assignedDrivers = (job.assignedDrivers || []).map(driver => driver.name).join(', ');
                
                 let destinationsDisplay = '';
                if (job.destinations && job.destinations.length > 0) {
                    if (job.destinations.length > 1) {
                        destinationsDisplay = `<p class="text-gray-400"><strong class="text-gray-200">Route:</strong> ${job.destinations.length} stops</p>`;
                    } else {
                        destinationsDisplay = `<p class="text-gray-400"><strong class="text-gray-200">To:</strong> ${job.destinations[0]}</p>`;
                    }
                } else {
                    destinationsDisplay = `<p class="text-gray-400"><strong class="text-gray-200">To:</strong> ${job.destination || 'N/A'}</p>`;
                }

                const today = new Date().toISOString().split('T')[0];
                const jobDateStr = job.jobDate === today ? '' : `<p class="text-orange-400 font-bold italic text-sm mt-1">${job.jobDate}</p>`;

                li.innerHTML = `
                    <div class="flex justify-between items-start">
                        <p class="font-bold text-white">${job.jobName || 'Unnamed Job'}</p>
                        ${statusTag}
                    </div>
                    ${jobDateStr}
                    <p class="text-gray-400"><strong class="text-gray-200">From:</strong> ${job.origin}</p>
                    ${destinationsDisplay}
                    <p class="text-gray-400"><strong class="text-gray-200">Openings:</strong> ${ (job.assignedDrivers || []).length} of ${job.driversNeeded}</p>
                    ${assignedDrivers ? `<p class="text-gray-400"><strong class="text-gray-200">Drivers:</strong> ${assignedDrivers}</p>` : ''}
                    <div id="job-eta-info-${job.id}" class="text-xs text-gray-300 mt-1"></div>
                `;
                jobsListEl.appendChild(li);
            });
        }

        async function deleteJob(jobId) {
            if (!checkPermission('canDeleteJob')) return;
            try {
                await deleteDoc(doc(db, AppState.jobsPath, jobId));
                await deleteDoc(doc(db, AppState.publicJobsPath, jobId)).catch(()=>{}); // Also delete public job
                showToast('Job has been deleted.', 'success');
                closeJobDetailsModal();
            } catch (error) {
                console.error("Error deleting job:", error);
                showToast("Failed to delete job.", "error");
            }
        }

        async function archiveJob(jobId) {
            if (!checkPermission('canDeleteJob')) return;
            try {
                await updateDoc(doc(db, AppState.jobsPath, jobId), { archived: true });
                await updateDoc(doc(db, AppState.publicJobsPath, jobId), { archived: true }).catch(()=>{});
                showToast('Job has been archived.', 'success');
                closeJobDetailsModal();
            } catch (error) {
                console.error("Error archiving job:", error);
                showToast("Failed to archive job.", "error");
            }
        }

        async function unarchiveJob(jobId) {
            if (!checkPermission('canDeleteJob')) return;
            try {
                await updateDoc(doc(db, AppState.jobsPath, jobId), { archived: false });
                await updateDoc(doc(db, AppState.publicJobsPath, jobId), { archived: false }).catch(()=>{});
                showToast('Job has been unarchived.', 'success');
                closeJobDetailsModal();
            } catch (error) {
                console.error("Error unarchiving job:", error);
                showToast("Failed to unarchive job.", "error");
            }
        }

        function renderAvailableJobsList() {
            const availableJobs = AppState.allJobs.filter(job => {
                const assignedDrivers = job.assignedDrivers || [];
                return !job.archived && job.status === 'unassigned' && assignedDrivers.length < job.driversNeeded && !assignedDrivers.some(d => d.id === AppState.currentUser?.id);
            });
            availableJobsList.innerHTML = availableJobs.length === 0 ? '<li class="text-gray-400 text-sm p-2">No job postings currently available.</li>' : '';
            availableJobs.forEach(job => {
                const li = document.createElement('li');
                li.className = 'bg-gray-800 p-3 rounded-md cursor-pointer';
                li.dataset.jobId = job.id;
                const finalDestination = job.destinations ? job.destinations[job.destinations.length - 1] : job.destination;
                li.innerHTML = `
                    <div class="flex flex-wrap justify-between items-start">
                        <div class="flex-grow">
                            <p class="font-bold text-white">${job.jobName || 'Unnamed Job'}</p>
                            <p class="text-gray-300"><strong class="text-white">From:</strong> ${job.origin}</p>
                            <p class="text-gray-300"><strong class="text-white">To:</strong> ${finalDestination}</p>
                            <p class="text-gray-300"><strong class="text-white">Openings:</strong> ${(job.assignedDrivers || []).length} of ${job.driversNeeded}</p>
                            <p class="text-gray-400 mt-1 italic text-xs">${job.note || 'No notes'}</p>
                        </div>
                        <button data-job-id="${job.id}" class="accept-job-btn mt-2 sm:mt-0 ml-auto px-3 py-1 bg-green-600 text-white text-xs font-semibold rounded hover:bg-green-700 flex-shrink-0">Accept</button>
                    </div>
                `;
                availableJobsList.appendChild(li);
            });
        }
        
        function renderMapObjects() {
            if (!AppState.map || !AppState.currentUser || !AppState.isAuthReady) return;

            const fiveMinutesAgo = Date.now() - (5 * 60 * 1000);
            const recentDrivers = AppState.activeDrivers.filter(driver => driver.timestamp && driver.timestamp.toMillis() > fiveMinutesAgo);
            const recentDriverIds = new Set(recentDrivers.map(d => d.id));

            if (AppState.isDispatchView) {
                recentDrivers.forEach(driver => {
                    if (driver.id === AppState.currentUser.id) return; 
                    const position = { lat: driver.location.latitude, lng: driver.location.longitude };
                    if (AppState.driverMapMarkers[driver.id]) {
                        AppState.driverMapMarkers[driver.id].position = position;
                    } else {
                        AppState.driverMapMarkers[driver.id] = new markerLibrary.AdvancedMarkerElement({
                            position, map: AppState.map,
                            content: buildMarkerContent(driver.name, '#f39c12'),
                            title: driver.name || 'Driver'
                        });
                    }
                });

                for (const driverId in AppState.driverMapMarkers) {
                    if (!recentDriverIds.has(driverId)) {
                        AppState.driverMapMarkers[driverId].map = null;
                        delete AppState.driverMapMarkers[driverId];
                    }
                }
            } else {
                for (const driverId in AppState.driverMapMarkers) {
                    AppState.driverMapMarkers[driverId].map = null;
                    delete AppState.driverMapMarkers[driverId];
                }
            }

            if (!AppState.isDispatchView) {
                const myLocationData = recentDrivers.find(d => d.id === AppState.currentUser.id);
                if (myLocationData) {
                    const pos = { lat: myLocationData.location.latitude, lng: myLocationData.location.longitude };
                    if (AppState.userMarker) {
                        AppState.userMarker.position = pos;
                    } else {
                        AppState.userMarker = new markerLibrary.AdvancedMarkerElement({
                            position: pos, map: AppState.map, title: 'Your Location',
                            content: buildMarkerContent('ME', '#4285F4')
                        });
                    }
                } else if (AppState.userMarker) {
                    AppState.userMarker.map = null;
                    AppState.userMarker = null;
                }
            } else if (AppState.userMarker) {
                AppState.userMarker.map = null;
                AppState.userMarker = null;
            }

            let jobsToRenderRoutesFor;
            if (!AppState.isDispatchView) {
                const myJob = AppState.allJobs.find(job => job.status === 'in-progress' && job.assignedDrivers.some(d => d.id === AppState.currentUser.id));
                jobsToRenderRoutesFor = myJob ? [myJob] : [];
            } else {
                jobsToRenderRoutesFor = AppState.allJobs.filter(job => job.status === 'in-progress' && job.assignedDrivers?.length > 0);
            }
            const jobsToRenderIds = new Set(jobsToRenderRoutesFor.map(j => j.id));

            jobsToRenderRoutesFor.forEach(job => {
                const driverId = !AppState.isDispatchView ? AppState.currentUser.id : job.assignedDrivers[0].id;
                const driver = recentDrivers.find(d => d.id === driverId);
                drawRouteForJob(job, driver?.location);
            });
            
            for (const jobId in AppState.jobRouteRenderers) {
                if (!jobsToRenderIds.has(jobId)) {
                    AppState.jobRouteRenderers[jobId].setMap(null);
                    delete AppState.jobRouteRenderers[jobId];
                }
            }
        }

        function drawRouteForJob(job, driverLocation) {
            if (!AppState.directionsService) return; 
            const jobId = job.id;
            let renderer = AppState.jobRouteRenderers[jobId];

            if (!renderer) {
                const jobColor = getJobColor(jobId);
                renderer = new routesLibrary.DirectionsRenderer({
                    map: AppState.map, suppressMarkers: true, preserveViewport: true,
                    polylineOptions: { strokeColor: jobColor, strokeWeight: 5, strokeOpacity: 0.8 },
                });
                AppState.jobRouteRenderers[jobId] = renderer;
            }
            
            const origin = driverLocation ? { lat: driverLocation.latitude, lng: driverLocation.longitude } : job.origin;
            const destinations = job.destinations || [job.destination];
            const finalDestination = destinations[destinations.length - 1];
            const waypoints = destinations.slice(0, -1).map(d => ({ location: d, stopover: true }));
            
            AppState.directionsService.route(
                { 
                    origin: origin, 
                    destination: finalDestination, 
                    waypoints: waypoints,
                    optimizeWaypoints: job.isOptimized || false,
                    travelMode: routesLibrary.TravelMode.DRIVING
                },
                (response, status) => {
                    const etaInfoEl = document.getElementById(`job-eta-info-${job.id}`);
                    if (status === "OK") {
                        renderer.setDirections(response);
                        const leg = response.routes[0].legs[response.routes[0].legs.length - 1];
                        if (etaInfoEl) {
                            etaInfoEl.innerHTML = `<span>Dist: ${leg.distance.text}</span> | <span>ETA: ${leg.duration.text}</span>`;
                        }
                        if (leg && !AppState.isDispatchView && leg.distance.value <= 200) { 
                            arrivedBtn.classList.remove('hidden');
                            arrivedBtn.dataset.jobId = job.id;
                        } else {
                            arrivedBtn.classList.add('hidden');
                        }
                    } else { 
                        if (etaInfoEl) etaInfoEl.innerHTML = '';
                        arrivedBtn.classList.add('hidden');
                        if(AppState.jobRouteRenderers[jobId]) {
                            AppState.jobRouteRenderers[jobId].setMap(null);
                            delete AppState.jobRouteRenderers[jobId];
                        }
                    }
                }
            );
        }
        
        function renderGeofencesList() {
            geofencesListEl.innerHTML = '';
            if (AppState.geofences.length === 0) {
                geofencesListEl.innerHTML = '<li class="text-gray-400 text-sm">No geofences created.</li>';
                return;
            }
            AppState.geofences.forEach(geofence => {
                const li = document.createElement('li');
                li.className = 'flex justify-between items-center bg-gray-800 p-2 rounded-md';
                li.innerHTML = `
                    <p class="text-sm text-gray-200">${geofence.name}</p>
                    <button data-geofence-id="${geofence.id}" class="delete-geofence-btn p-1 rounded-full hover:bg-red-800" title="Delete Geofence">
                        <svg class="w-4 h-4 text-red-400" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg>
                    </button>
                `;
                geofencesListEl.appendChild(li);
            });
        }

        geofencesListEl.addEventListener('click', (e) => {
            const deleteBtn = e.target.closest('.delete-geofence-btn');
            if (deleteBtn) {
                const geofenceId = deleteBtn.dataset.geofenceId;
                showConfirmModal('Delete Geofence?', 'This action is permanent and cannot be undone.', async () => {
                    try {
                        await deleteDoc(doc(db, `${AppState.companiesPath}/${AppState.companyId}/geofences`, geofenceId));
                        showToast('Geofence deleted successfully!', 'success');
                    } catch (error) {
                        console.error("Error deleting geofence:", error);
                        showToast("Failed to delete geofence.", "error");
                    }
                });
            }
        });

        function renderSavedTrailsList() {
            savedTrailsListEl.innerHTML = '';
            if (AppState.trails.length === 0) {
                savedTrailsListEl.innerHTML = '<li class="text-gray-400 text-sm">No trails saved.</li>';
                return;
            }
            AppState.trails.forEach(trail => {
                const li = document.createElement('li');
                li.className = 'flex justify-between items-center bg-gray-800 p-2 rounded-md cursor-pointer';
                li.dataset.trailId = trail.id;
                li.innerHTML = `
                    <p class="text-sm text-gray-200">${trail.name}</p>
                    <button data-trail-id="${trail.id}" class="delete-trail-btn p-1 rounded-full hover:bg-red-800" title="Delete Trail">
                        <svg class="w-4 h-4 text-red-400" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg>
                    </button>
                `;
                savedTrailsListEl.appendChild(li);
            });
        }

        savedTrailsListEl.addEventListener('click', (e) => {
            const trailLi = e.target.closest('li[data-trail-id]');
            const deleteBtn = e.target.closest('.delete-trail-btn');

            if (deleteBtn) {
                const trailId = deleteBtn.dataset.trailId;
                showConfirmModal('Delete Trail?', 'This action is permanent and cannot be undone.', async () => {
                    try {
                        await deleteDoc(doc(db, `${AppState.companiesPath}/${AppState.companyId}/trails`, trailId));
                        showToast('Trail deleted successfully!', 'success');
                    } catch (error) {
                        console.error("Error deleting trail:", error);
                        showToast("Failed to delete trail.", "error");
                    }
                });
            } else if (trailLi) {
                const trailId = trailLi.dataset.trailId;
                const trail = AppState.trails.find(t => t.id === trailId);
                if (trail) {
                    if (AppState.currentTrail) {
                        AppState.currentTrail.setMap(null);
                    }
                    AppState.currentTrail = new mapsLibrary.Polyline({
                        path: trail.path,
                        map: AppState.map,
                        strokeColor: '#0000FF',
                        strokeOpacity: 1.0,
                        strokeWeight: 3
                    });
                    trailNavigationContainer.classList.remove('hidden');
                }
            }
        });

        function renderGeofencesOnMap() {
            for (const geofenceId in AppState.geofencePolygons) {
                AppState.geofencePolygons[geofenceId].setMap(null);
            }
            AppState.geofencePolygons = {};

            AppState.geofences.forEach(geofence => {
                const polygon = new mapsLibrary.Polygon({
                    paths: geofence.path,
                    strokeColor: '#FF0000',
                    strokeOpacity: 0.8,
                    strokeWeight: 2,
                    fillColor: '#FF0000',
                    fillOpacity: 0.35,
                    map: AppState.map
                });
                AppState.geofencePolygons[geofence.id] = polygon;
            });
        }

        function checkGeofenceTransitions(driverId, newPos) {
            const driver = AppState.activeDrivers.find(d => d.id === driverId);
            const lastStatus = driver && driver.geofenceStatus ? driver.geofenceStatus : {};

            AppState.geofences.forEach(geofence => {
                const polygon = new mapsLibrary.Polygon({ paths: geofence.path });
                const isInside = geometryLibrary.poly.containsLocation(newPos, polygon);
                const wasInside = lastStatus[geofence.id] === 'inside';

                if (isInside && !wasInside) {
                    showToast(`${driver.name} has entered the ${geofence.name} zone.`, 'info');
                    const driverLocRef = doc(db, AppState.driversPath, driverId);
                    updateDoc(driverLocRef, { [`geofenceStatus.${geofence.id}`]: 'inside' });
                } else if (!isInside && wasInside) {
                    showToast(`${driver.name} has left the ${geofence.name} zone.`, 'info');
                    const driverLocRef = doc(db, AppState.driversPath, driverId);
                    updateDoc(driverLocRef, { [`geofenceStatus.${geofence.id}`]: 'outside' });
                }
            });
        }

        function renderDriversList() {
            driversListEl.innerHTML = '';
            const fiveMinutesAgo = Date.now() - (5 * 60 * 1000);
            const recentDrivers = AppState.activeDrivers.filter(driver => driver.timestamp && driver.timestamp.toMillis() > fiveMinutesAgo);

            if (recentDrivers.length === 0) {
                driversListEl.innerHTML = '<li class="text-gray-400 text-sm">No active drivers.</li>';
                return;
            }
            recentDrivers.forEach(driver => {
                const user = AppState.allUsers.find(u => u.id === driver.id);
                const phone = user ? user.phone : '';
                const li = document.createElement('li');
                
                let statusText = driver.status || 'Online';
                let statusColor = 'bg-gray-500';

                const assignedJob = AppState.allJobs.find(job => 
                    job.status === 'in-progress' && 
                    job.assignedDrivers.some(d => d.id === driver.id)
                );

                if (assignedJob) {
                    statusText = `On Trip: ${assignedJob.jobName}`;
                    statusColor = 'bg-yellow-500';
                } else if (driver.status === 'Available') {
                    statusColor = 'bg-green-500';
                } else if (driver.status === 'On Break') {
                    statusColor = 'bg-orange-500';
                } else if (driver.status.startsWith('On Trip') && !assignedJob) {
                    statusText = 'Available';
                    statusColor = 'bg-green-500';
                }

                let actionButtons = '';
                if (checkPermission('canManageDrivers')) {
                    actionButtons = `
                        <button data-driver-id="${driver.id}" class="remove-driver-btn p-1 rounded-full hover:bg-red-800" title="Remove Driver">
                            <svg class="w-4 h-4 text-red-400" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                        </button>
                    `;
                }

                li.className = `flex justify-between items-center bg-gray-800 p-2 rounded-md border-l-4 border-green-500`;
                li.innerHTML = `
                    <div>
                        <p class="text-sm font-bold text-gray-200">${driver.name || 'Unnamed Driver'}</p>
                        <p class="text-xs text-gray-400">${phone || 'No mobile'}</p>
                        <p class="text-xs text-gray-400">ETA: ${driver.eta || 'N/A'}</p>
                    </div>
                    <div class="flex items-center space-x-2">
                        <span class="text-xs font-semibold text-gray-400 mr-2">${statusText}</span>
                        <span class="w-3 h-3 rounded-full ${statusColor} mr-2"></span>
                        ${actionButtons}
                    </div>
                `;
                driversListEl.appendChild(li);
            });
        }

        function renderUI() {
            if (!AppState.isAuthReady) return; 
            
            userWelcomeEl.textContent = `Welcome, ${AppState.currentUser.name}!`;

            if (!AppState.companyId) {
                dispatchUi.classList.add('hidden');
                driverUi.classList.add('hidden');
                adminBadge.classList.add('hidden');
                return;
            }

            driverUi.classList.toggle('hidden', AppState.isDispatchView);
            dispatchUi.classList.toggle('hidden', !AppState.isDispatchView);
            
            if (!AppState.isDispatchView) {
                startAutomaticLocationSharing();
                updateDriverJobPanels();
            } else {
                stopAutomaticLocationSharing();
                renderAllJobsList();
                renderDriversList();
            }
            
            const isAdmin = checkPermission('canManageDrivers');
            adminControls.classList.toggle('hidden', !isAdmin);
            adminBadge.classList.toggle('hidden', !isAdmin);
            managementActionsPanel.classList.toggle('hidden', !checkPermission('canCreateJob'));
        }

        function updateDriverJobPanels() {
            const myJob = AppState.allJobs.find(job => job.status === 'in-progress' && job.assignedDrivers.some(d => d.id === AppState.currentUser.id));
            if (myJob) {
                currentJobPanel.classList.remove('hidden');
                availableJobsPanel.classList.add('hidden'); 
                driverStatusSelect.disabled = true;
                
                let destinationsHTML = '';
                if (myJob.destinations && myJob.destinations.length > 0) {
                    if (myJob.destinations.length > 1) {
                        destinationsHTML = `<p><strong class="text-white">Route:</strong></p><ol class="list-decimal list-inside text-xs">${myJob.destinations.map(d => `<li>${d}</li>`).join('')}</ol>`;
                    } else {
                        destinationsHTML = `<p><strong class="text-white">To:</strong> ${myJob.destinations[0]}</p>`;
                    }
                } else {
                    destinationsHTML = `<p><strong class="text-white">To:</strong> ${myJob.destination || 'N/A'}</p>`;
                }

                currentJobDetails.innerHTML = `
                    <p class="font-bold text-white">${myJob.jobName || 'Unnamed Job'}</p>
                    <p><strong class="text-white">From:</strong> ${myJob.origin}</p>
                    ${destinationsHTML}
                    <p class="mt-1 italic"><strong class="text-white">Note:</strong> ${myJob.note || 'N/A'}</p>
                `;
                completeJobBtn.dataset.jobId = myJob.id;
                startNavigationBtn.dataset.jobId = myJob.id;
                startNavigationBtn.dataset.destination = myJob.destinations[myJob.destinations.length - 1];
            } else {
                currentJobPanel.classList.add('hidden');
                availableJobsPanel.classList.remove('hidden'); 
                driverStatusSelect.disabled = false;
                arrivedBtn.classList.add('hidden'); 
            }
            renderAvailableJobsList();
        }

        async function loadGoogleMapsScript() {
            const apiKey = localStorage.getItem('googleMapsApiKey');
            if (!apiKey) {
                showToast("Google Maps API Key is not set. Please set it in the settings.", "error");
                document.getElementById("map").innerHTML = `<div class="text-center p-4"><p class="font-bold text-red-400">API Key Missing</p><p class="text-gray-400">Please set your Google Maps API key in the settings menu.</p></div>`;
                settingsModal.classList.remove('hidden');
                return;
            }

            const script = document.createElement('script');
            script.src = `https://maps.googleapis.com/maps/api/js?key=${apiKey}&libraries=places,routes,drawing,geometry&v=weekly&loading=async&callback=onGoogleMapsLoaded`;
            script.async = true;
            script.defer = true;
            document.head.appendChild(script);
        }

        window.onGoogleMapsLoaded = async () => {
            console.log("Google Maps libraries loaded successfully.");
            
            mapsLibrary = google.maps;
            coreLibrary = google.maps;
            markerLibrary = google.maps.marker;
            placesLibrary = google.maps.places;
            routesLibrary = google.maps;
            drawingLibrary = google.maps.drawing;
            geometryLibrary = google.maps.geometry;

            if(!AppState.publicMap && !AppState.publicDriverMap) initMap();
            AppState.directionsService = new google.maps.DirectionsService();
            setupAutocomplete();
        }

        function setupAutocomplete() {
            const inputsToUpdate = [
                'job-origin-input',
                'location-share-destination'
            ];
        
            inputsToUpdate.forEach(inputId => {
                const input = document.getElementById(inputId);
                if (input) {
                    new google.maps.places.Autocomplete(input);
                }
            });
        }


        function showToast(message, type = 'info') {
            const toastContainer = document.getElementById('toast-container');
            const toast = document.createElement('div');
            toast.className = `p-4 mb-2 rounded-md shadow-lg text-white ${type === 'error' ? 'bg-red-600' : type === 'success' ? 'bg-green-600' : 'bg-blue-600'}`;
            toast.textContent = message;
            toastContainer.appendChild(toast);
            setTimeout(() => {
                toast.classList.add('opacity-0', 'transition-opacity', 'duration-300');
                setTimeout(() => toast.remove(), 300);
            }, 3000);
        }

        function showConfirmModal(title, message, onConfirm) {
            confirmModalTitle.textContent = title;
            confirmModalMessage.textContent = message;
            AppState.confirmCallback = onConfirm; 
            confirmModal.classList.remove('hidden');
        }

        function showCommentModal(title, callback) {
            commentModalTitle.textContent = title;
            commentInput.value = '';
            podUploadInput.value = '';
            AppState.commentCallback = callback;
            commentModal.classList.remove('hidden');
        }

        const handleEscKey = (e) => {
            if (e.key === 'Escape' && !jobDetailsModal.classList.contains('hidden')) {
                closeJobDetailsModal();
            }
        };

        function closeJobDetailsModal() {
            if (AppState.currentJobChatUnsubscribe) {
                AppState.currentJobChatUnsubscribe();
                AppState.currentJobChatUnsubscribe = null;
            }
            jobDetailsModal.classList.add('hidden');
            document.removeEventListener('keydown', handleEscKey);
        }

        async function showJobDetailsModal(job) {
            AppState.currentJobIdForModal = job.id;
            const assignedDrivers = (job.assignedDrivers || []).map(driver => driver.name).join(', ');
            
            let destinationsHTML = '';
            if (job.destinations && job.destinations.length > 0) {
                if (job.destinations.length > 1) {
                    destinationsHTML = `<p><strong>Route:</strong></p><ol class="list-decimal list-inside text-sm">${job.destinations.map(d => `<li>${d}</li>`).join('')}</ol>`;
                } else {
                    destinationsHTML = `<p><strong>To:</strong> ${job.destinations[0]}</p>`;
                }
            } else {
                destinationsHTML = `<p><strong>To:</strong> ${job.destination || 'N/A'}</p>`;
            }

            jobDetailsContent.innerHTML = `
                <p><strong>Job Name:</strong> ${job.jobName || 'N/A'}</p>
                <p><strong>Date:</strong> ${job.jobDate || 'N/A'}</p>
                <p><strong>Status:</strong> ${job.archived ? 'Archived' : job.status}</p>
                <p><strong>From:</strong> ${job.origin}</p>
                ${destinationsHTML}
                <p><strong>Contact:</strong> ${job.contactName || 'N/A'} - ${job.contactNumber || 'N/A'}</p>
                <p><strong>Distance:</strong> ${job.totalDistance || 'N/A'}</p>
                <p><strong>Est. Travel Time:</strong> ${formatDuration(job.totalDuration)}</p>
                <p><strong>Drivers Needed:</strong> ${job.driversNeeded}</p>
                <p><strong>Assigned Drivers:</strong> ${assignedDrivers || 'None'}</p>
                <p class="mt-2 italic"><strong class="text-white">Note:</strong> ${job.note || 'N/A'}</p>
            `;
            
            const isDispatcher = checkPermission('canCreateJob');

            editJobBtn.classList.add('hidden');
            archiveJobBtn.classList.add('hidden');
            deleteJobBtn.classList.add('hidden');
            unarchiveJobModalBtn.classList.add('hidden');
            jobDetailsDriverActions.classList.add('hidden');
            jobDetailsDriverCancelBtn.classList.add('hidden');
            jobChatInput.disabled = false;
            jobChatForm.querySelector('button').disabled = false;
            finalizeJobBtn.classList.add('hidden'); // FINALIZE JOB FIX: Reset/hide button initially
            
            const isAssignedToMe = (job.assignedDrivers || []).some(d => d.id === AppState.currentUser.id);

            if (job.archived) {
                unarchiveJobModalBtn.classList.remove('hidden');
                deleteJobBtn.classList.remove('hidden');
                jobChatInput.disabled = true;
                jobChatForm.querySelector('button').disabled = true;
            } else {
                if (isDispatcher) {
                    archiveJobBtn.classList.remove('hidden');
                    deleteJobBtn.classList.remove('hidden');
                    editJobBtn.classList.toggle('hidden', job.status === 'completed' || job.status === 'cancelled');
                    // FINALIZE JOB FIX: Show finalize button for pending jobs
                    if (job.status === 'pending-completion') {
                        finalizeJobBtn.classList.remove('hidden');
                        finalizeJobBtn.dataset.jobId = job.id;
                    }
                } else { 
                    jobDetailsDriverActions.classList.remove('hidden');
                    jobDetailsAcceptBtn.classList.toggle('hidden', job.status !== 'unassigned');
                    jobDetailsDriverCancelBtn.classList.toggle('hidden', !isAssignedToMe || job.status !== 'in-progress');
                }
            }
            
            editJobBtn.dataset.jobId = job.id;
            archiveJobBtn.dataset.jobId = job.id;
            deleteJobBtn.dataset.jobId = job.id;
            unarchiveJobModalBtn.dataset.jobId = job.id;
            jobDetailsAcceptBtn.dataset.jobId = job.id;
            jobDetailsDriverCancelBtn.dataset.jobId = job.id;
            
            if (job.proofOfDeliveryURL) {
                podImage.src = job.proofOfDeliveryURL;
                podSection.classList.remove('hidden');
            } else {
                podSection.classList.add('hidden');
            }

            if (job.driverCompletionComment) {
                driverCompletionComment.textContent = job.driverCompletionComment;
                driverCompletionCommentSection.classList.remove('hidden');
            } else {
                driverCompletionCommentSection.classList.add('hidden');
            }

            if (job.dispatcherClosingComment) {
                dispatcherClosingComment.textContent = job.dispatcherClosingComment;
                dispatcherClosingCommentSection.classList.remove('hidden');
            } else {
                dispatcherClosingCommentSection.classList.add('hidden');
            }

            trackingLinkContainer.innerHTML = ''; // Clear previous button
            if (isDispatcher) {
                trackingLinkSection.classList.remove('hidden');
                const button = document.createElement('button');
                button.className = 'w-full px-4 py-2 bg-teal-600 text-white rounded-lg hover:bg-teal-700';
                button.dataset.jobId = job.id;
                if (job.thirdPartyInviteId) {
                    button.textContent = 'View Tracking Link';
                    button.id = 'view-tracking-link-btn';
                } else {
                    button.textContent = 'Create Tracking Link';
                    button.id = 'create-tracking-link-btn';
                }
                trackingLinkContainer.appendChild(button);
                if(job.archived) button.disabled = true;
            } else if (job.thirdPartyInviteId) { // Driver can only see/share if it exists
                trackingLinkSection.classList.remove('hidden');
                const button = document.createElement('button');
                button.className = 'w-full px-4 py-2 bg-teal-600 text-white rounded-lg hover:bg-teal-700';
                button.dataset.jobId = job.id;
                button.textContent = 'View Tracking Link';
                button.id = 'view-tracking-link-btn';
                trackingLinkContainer.appendChild(button);
                if(job.archived) button.disabled = true;
            } else {
                trackingLinkSection.classList.add('hidden');
            }

            jobHistoryLog.innerHTML = '';
            if (job.log && job.log.length > 0) {
                job.log.sort((a,b) => a.timestamp.toMillis() - b.timestamp.toMillis()).forEach(entry => {
                    const li = document.createElement('li');
                    li.textContent = `[${entry.timestamp ? entry.timestamp.toDate().toLocaleString() : ''}] ${entry.text}`;
                    jobHistoryLog.appendChild(li);
                });
            } else {
                jobHistoryLog.innerHTML = '<li>No history entries.</li>';
            }
            jobChatForm.dataset.jobId = job.id;
            listenForJobMessages(job.id);
            jobDetailsModal.classList.remove('hidden');
            document.addEventListener('keydown', handleEscKey);

            if (checkPermission('canCreateJob')) {
                const userDocRef = doc(db, AppState.globalUsersPath, AppState.currentUser.id);
                await updateDoc(userDocRef, {
                    [`lastRead.${job.id}`]: Date.now()
                }).catch(err => console.error("Error updating last read timestamp:", err));
            }
        }
        
        function showSpinner(button) {
            button.disabled = true;
            button.querySelector('.btn-text').classList.add('hidden');
            button.querySelector('.spinner').classList.remove('hidden');
        }

        function hideSpinner(button) {
            button.disabled = false;
            button.querySelector('.btn-text').classList.remove('hidden');
            button.querySelector('.spinner').classList.add('hidden');
        }
        
        async function deleteUserFromDb(userId) {
            if (!checkPermission('canManageDrivers')) {
                showToast('You do not have permission to remove users.', 'error');
                return;
            }

            try {
                await deleteDoc(doc(db, AppState.membersPath, userId));
                await deleteDoc(doc(db, AppState.driversPath, userId)).catch(() => {});
                await updateDoc(doc(db, AppState.globalUsersPath, userId), { currentCompanyId: null });

                showToast('User removed from company.', 'success');
                renderUserRoleManagement(); 

            } catch (error) {
                console.error("Error removing user from company:", error);
                showToast('Failed to remove user.', 'error');
            }
        }

        // --- Event Listeners ---
        logoutBtn.addEventListener('click', async () => {
            try {
                await signOut(auth);
            } catch (error) {
                console.error('Logout Error:', error);
                showToast('Error logging out.', 'error');
            }
        });

        googleSigninBtn.addEventListener('click', async () => {
            try {
                await signInWithPopup(auth, new GoogleAuthProvider());
            } catch (error) {
                console.error("Google Sign-In Error:", error);
                showToast('Google Sign-In Error: ' + error.message, 'error');
            }
        });

        settingsBtn.addEventListener('click', () => {
            googleMapsApiKeyInput.value = localStorage.getItem('googleMapsApiKey') || '';
            firebaseConfigInput.value = localStorage.getItem('firebaseConfig') || '';
            settingsModal.classList.remove('hidden');
        });

        saveApiKeyBtn.addEventListener('click', () => {
            const apiKey = googleMapsApiKeyInput.value.trim();
            if (apiKey) {
                localStorage.setItem('googleMapsApiKey', apiKey);
                showToast("API Key saved! Please refresh the page for changes to take effect.", "success");
            } else {
                localStorage.removeItem('googleMapsApiKey');
                showToast("API Key removed.", "info");
            }
            settingsModal.classList.add('hidden');
        });


        openProfileModalBtn.addEventListener('click', () => {
            settingsModal.classList.add('hidden');
            profileNameInput.value = AppState.currentUser.name;
            profilePhoneInput.value = AppState.currentUser.phone || '';
            profileModal.classList.remove('hidden');
        });
        
        openAdminSettingsBtn.addEventListener('click', () => {
            settingsModal.classList.add('hidden');
            renderUserRoleManagement();
            adminSettingsModal.classList.remove('hidden');
        });

        profileForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            const newName = profileNameInput.value.trim();
            const newPhone = profilePhoneInput.value.trim();
            if (newName) {
                try {
                    await updateDoc(doc(db, AppState.globalUsersPath, AppState.currentUser.id), { 
                        name: newName,
                        phone: newPhone 
                    });
                    await updateDoc(doc(db, AppState.membersPath, AppState.currentUser.id), { name: newName });
                    showToast('Profile updated!', 'success');
                } catch (error) {
                    console.error("Error updating profile:", error);
                    showToast("Failed to update profile.", "error");
                }
            }
            profileModal.classList.add('hidden');
        });

        function openCreateJobModal(jobToEdit = null) {
            createJobForm.reset();
            destinationsContainer.innerHTML = '';
            editingJobIdInput.value = '';
            
            if (jobToEdit) {
                createJobModalTitle.textContent = 'Edit Job';
                editingJobIdInput.value = jobToEdit.id;
                jobNameInput.value = jobToEdit.jobName || '';
                jobDateInput.value = jobToEdit.jobDate || new Date().toISOString().split('T')[0];
                jobOriginInput.value = jobToEdit.origin || '';
                contactNameInput.value = jobToEdit.contactName || '';
                contactNumberInput.value = jobToEdit.contactNumber || '';
                jobNoteInput.value = jobToEdit.note || '';
                driversNeededInput.value = jobToEdit.driversNeeded || 1;
                optimizeRouteCheckbox.checked = jobToEdit.isOptimized || false;

                (jobToEdit.destinations || []).forEach(dest => addDestinationInput(dest));
                assignDriverSelect.parentElement.classList.add('hidden');
            } else {
                createJobModalTitle.textContent = 'Create New Job';
                jobDateInput.value = new Date().toISOString().split('T')[0];
                addDestinationInput(); 
                assignDriverSelect.parentElement.classList.remove('hidden');
                const availableDrivers = AppState.allUsers.filter(u => {
                    const isActive = AppState.activeDrivers.some(d => d.id === u.id && d.status === 'On Trip');
                    return !isActive;
                });
                assignDriverSelect.innerHTML = '<option value="">Post as open job</option>';
                availableDrivers.forEach(driver => {
                    const option = document.createElement('option');
                    option.value = driver.id;
                    option.textContent = driver.name;
                    assignDriverSelect.appendChild(option);
                });
            }
            createJobModal.classList.remove('hidden');
        }

        openCreateJobModalBtn.addEventListener('click', () => openCreateJobModal());

        jobDashboardPanel.addEventListener('click', (e) => {
            if (e.target.matches('.tab-btn')) {
                document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
                e.target.classList.add('active');
                AppState.activeJobTab = e.target.dataset.tab;
                renderAllJobsList();
            }
        });

        jobsListEl.addEventListener('click', (e) => {
            const li = e.target.closest('li[data-job-id]');
            if (li) {
                const job = AppState.allJobs.find(j => j.id === li.dataset.jobId);
                if (job) showJobDetailsModal(job);
            }
        });

        currentJobPanel.addEventListener('click', (e) => {
             if (e.target.closest('button')) return;
             const myJob = AppState.allJobs.find(job => job.status === 'in-progress' && job.assignedDrivers.some(d => d.id === AppState.currentUser.id));
             if (myJob) {
                 showJobDetailsModal(myJob);
             }
        });
        
        async function acceptJob(jobId) {
            const jobRef = doc(db, AppState.jobsPath, jobId);
            try {
                await runTransaction(db, async (transaction) => {
                    const jobDoc = await transaction.get(jobRef);
                    if (!jobDoc.exists()) throw "Job does not exist!";
                    const jobData = jobDoc.data();
                    if ((jobData.assignedDrivers || []).length >= jobData.driversNeeded) throw "All driver slots are filled.";
                    
                    const newLogEntry = { text: `Accepted by ${AppState.currentUser.name}`, timestamp: new Date() };
                    const updateData = {
                        status: (jobData.assignedDrivers || []).length + 1 >= jobData.driversNeeded ? 'in-progress' : 'unassigned',
                        assignedDrivers: arrayUnion({ id: AppState.currentUser.id, name: AppState.currentUser.name }),
                    };

                    if (jobData.log) {
                        updateData.log = arrayUnion(newLogEntry);
                    } else {
                        updateData.log = [newLogEntry];
                    }
                    
                    transaction.update(jobRef, updateData);

                    if (AppState.isSharingLocation) {
                        transaction.update(doc(db, AppState.driversPath, AppState.currentUser.id), { status: 'On Trip' });
                    }
                });
                showToast("Job accepted!", "success");
            } catch (error) {
                console.error("Error accepting job:", error);
                showToast(error.toString(), "error");
            }
        }

        async function cancelAcceptedJob(jobId) {
            const jobRef = doc(db, AppState.jobsPath, jobId);
            try {
                await runTransaction(db, async (transaction) => {
                    const jobDoc = await transaction.get(jobRef);
                    if (!jobDoc.exists()) throw "Job not found";

                    transaction.update(jobRef, {
                        assignedDrivers: arrayRemove({ id: AppState.currentUser.id, name: AppState.currentUser.name }),
                        status: 'unassigned',
                        log: arrayUnion({ text: `Assignment cancelled by ${AppState.currentUser.name}`, timestamp: new Date() })
                    });
                    
                    if (AppState.isSharingLocation) {
                        transaction.update(doc(db, AppState.driversPath, AppState.currentUser.id), { status: 'Available' });
                    }
                });
                showToast("You have been removed from the job.", "success");
                closeJobDetailsModal();
            } catch (error) {
                console.error("Error cancelling accepted job:", error);
                showToast("Could not cancel job assignment.", "error");
            }
        }

        availableJobsList.addEventListener('click', async (e) => {
            if (e.target.classList.contains('accept-job-btn')) {
                const button = e.target;
                const { jobId } = button.dataset;
                button.disabled = true;
                button.textContent = 'Accepting...';
                await acceptJob(jobId);
                button.disabled = false;
                button.textContent = 'Accept';
            } else {
                const li = e.target.closest('li[data-job-id]');
                if (li) {
                    const job = AppState.allJobs.find(j => j.id === li.dataset.jobId);
                    if (job) showJobDetailsModal(job);
                }
            }
        });
        
        async function completeJob(jobId, comment, file) {
            const jobRef = doc(db, AppState.jobsPath, jobId);
            let podURL = '';
            if (file) {
                try {
                    const storageRef = ref(storage, `proof_of_delivery/${AppState.companyId}/${jobId}/${file.name}`);
                    await uploadBytes(storageRef, file);
                    podURL = await getDownloadURL(storageRef);
                } catch (error) {
                    console.error("Error uploading POD:", error);
                    showToast("Could not upload proof of delivery image.", "error");
                    return;
                }
            }

            try {
                await runTransaction(db, async (transaction) => {
                    const jobDoc = await transaction.get(jobRef);
                    if (!jobDoc.exists()) throw "Job not found";
                    const jobData = jobDoc.data();
                    const newAssignedDrivers = (jobData.assignedDrivers || []).filter(d => d.id !== AppState.currentUser.id);
                    
                    const updateData = {
                        status: 'pending-completion',
                        driverCompletionComment: comment,
                        assignedDrivers: newAssignedDrivers,
                        proofOfDeliveryURL: podURL || jobData.proofOfDeliveryURL || null, 
                        log: arrayUnion({ text: `Marked as pending completion by ${AppState.currentUser.name}`, timestamp: new Date() })
                    };

                    transaction.update(jobRef, updateData);

                    if (AppState.isSharingLocation) {
                        transaction.update(doc(db, AppState.driversPath, AppState.currentUser.id), { status: 'Available', eta: '' });
                    }
                });
                showToast("Job pending completion!", "success");
            } catch (error) {
                console.error("Error completing job:", error);
                showToast("Could not complete job.", "error");
            }
        }

        async function closeOutJob(jobId, comment) {
            const jobRef = doc(db, AppState.jobsPath, jobId);
            try {
                await updateDoc(jobRef, {
                    status: 'completed',
                    dispatcherClosingComment: comment,
                    log: arrayUnion({ text: `Closed out by ${AppState.currentUser.name}`, timestamp: new Date() })
                });
                showToast("Job finalized and completed!", "success");
            } catch (error) {
                console.error("Error closing out job:", error);
                showToast("Could not finalize job.", "error");
            }
        }

        completeJobBtn.addEventListener('click', (e) => {
            const jobId = e.target.dataset.jobId;
            showCommentModal('Add Completion Comment', (comment, file) => {
                completeJob(jobId, comment, file);
            });
        });
        
        arrivedBtn.addEventListener('click', (e) => {
            const jobId = e.target.dataset.jobId;
            showCommentModal('Add Completion Comment', (comment, file) => {
                completeJob(jobId, comment, file);
            });
        });

        startNavigationBtn.addEventListener('click', (e) => {
            const { jobId, destination } = e.target.dataset;
            const job = AppState.allJobs.find(j => j.id === jobId);
            if (job && job.customerNotificationEnabled) {
                showToast(`Simulated SMS sent to ${job.contactNumber || 'customer'}.`, 'success');
            }
            window.open(`https://www.google.com/maps/dir/?api=1&destination=${encodeURIComponent(destination)}&travelmode=driving`, '_blank');
        });

        createJobForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            if (!checkPermission('canCreateJob')) return;
            const button = document.getElementById('create-job-submit-btn');
            showSpinner(button);

            const destinations = Array.from(destinationsContainer.querySelectorAll('input')).map(input => input.value.trim()).filter(val => val);
            if (destinations.length === 0) {
                showToast('Please add at least one destination.', 'error');
                hideSpinner(button);
                return;
            }

            const editingJobId = editingJobIdInput.value;

            const jobData = { 
                jobName: jobNameInput.value.trim(), 
                jobDate: jobDateInput.value,
                origin: jobOriginInput.value.trim(), 
                destinations: destinations,
                isOptimized: optimizeRouteCheckbox.checked,
                contactName: contactNameInput.value.trim(),
                contactNumber: contactNumberInput.value.trim(),
                note: jobNoteInput.value.trim(), 
                driversNeeded: parseInt(driversNeededInput.value, 10),
                totalDistance: '',
                totalDuration: 0,
            };

            const finalDestination = destinations[destinations.length - 1];
            const waypoints = destinations.slice(0, -1).map(d => ({ location: d, stopover: true }));
            
            AppState.directionsService.route({
                origin: jobData.origin,
                destination: finalDestination,
                waypoints: waypoints,
                optimizeWaypoints: jobData.isOptimized,
                travelMode: routesLibrary.TravelMode.DRIVING
            }, async (response, status) => {
                if (status === 'OK') {
                    let totalDistanceMeters = 0;
                    let totalDurationSeconds = 0;
                    response.routes[0].legs.forEach(leg => {
                        totalDistanceMeters += leg.distance.value;
                        totalDurationSeconds += leg.duration.value;
                    });
                    jobData.totalDistance = `${(totalDistanceMeters / 1609.34).toFixed(1)} mi`;
                    jobData.totalDuration = totalDurationSeconds;
                }

                try {
                    if (editingJobId) {
                        const jobRef = doc(db, AppState.jobsPath, editingJobId);
                        jobData.log = arrayUnion({ text: `Job details updated by ${AppState.currentUser.name}`, timestamp: new Date() });
                        await updateDoc(jobRef, jobData);
                        showToast('Job updated successfully.', 'success');
                    } else {
                        jobData.assignedDrivers = [];
                        jobData.createdAt = serverTimestamp();
                        jobData.archived = false;
                        jobData.status = 'unassigned';
                        
                        const assignedDriverId = assignDriverSelect.value;
                        if (assignedDriverId) {
                            const driver = AppState.allUsers.find(u => u.id === assignedDriverId);
                            jobData.assignedDrivers.push({id: driver.id, name: driver.name });
                            jobData.status = 'in-progress';
                        }

                        const docRef = await addDoc(collection(db, AppState.jobsPath), jobData);

                        let logEntries = [{ text: `Created by ${AppState.currentUser.name}`, timestamp: new Date() }];
                        if (assignedDriverId) {
                            const driver = AppState.allUsers.find(u => u.id === assignedDriverId);
                            logEntries.push({ text: `Assigned to ${driver.name}`, timestamp: new Date() });
                        }
                        
                        await updateDoc(docRef, { log: logEntries });
                        showToast('New job created.', 'success');
                    }
                    
                    createJobForm.reset();
                    createJobModal.classList.add('hidden');
                } catch (error) {
                    showToast(`Error: ${error.message}`, 'error');
                } finally {
                    hideSpinner(button);
                }
            });
        });

        function renderUserRoleManagement() {
            userRoleList.innerHTML = '';
            const permissions = ['canCreateJob', 'canDeleteJob', 'canManageDrivers'];
            AppState.allUsers.forEach(user => {
                const li = document.createElement('li');
                li.className = 'bg-gray-700 p-3 rounded relative';
                
                const isCurrentUser = user.id === AppState.currentUser.id;

                let deleteButtonHTML = '';
                if (!isCurrentUser) {
                    deleteButtonHTML = `<button data-user-id="${user.id}" data-user-email="${user.email || user.id}" class="delete-user-btn p-1 rounded-full hover:bg-red-800 absolute top-2 right-2" title="Delete User">
                        <svg class="w-4 h-4 text-red-400" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg>
                    </button>`;
                }

                let checkboxesHTML = permissions.map(perm => {
                    const isChecked = user.permissions?.[perm] === true;
                    return `<label class="flex items-center space-x-2">
                        <input type="checkbox" data-user-id="${user.id}" data-permission="${perm}" class="permission-checkbox bg-gray-600 border-gray-500 rounded" ${isChecked ? 'checked' : ''}>
                        <span class="text-sm">${perm}</span>
                    </label>`;
                }).join('');

                li.innerHTML = `
                    <p class="text-sm font-bold text-gray-200 truncate mb-2 pr-8">${user.name || user.email}</p>
                    ${deleteButtonHTML}
                    <div class="grid grid-cols-2 gap-2">${checkboxesHTML}</div>
                `;
                userRoleList.appendChild(li);
            });
        }

        userRoleList.addEventListener('click', async (e) => {
            const deleteBtn = e.target.closest('.delete-user-btn');
            if (deleteBtn) {
                const { userId, userEmail } = deleteBtn.dataset;
                showConfirmModal(
                    'Remove User?', 
                    `This will remove "${userEmail}" from the company. They will need to be invited again to rejoin.`, 
                    () => deleteUserFromDb(userId)
                );
            }
        });

        userRoleList.addEventListener('change', async (e) => {
            if (e.target.classList.contains('permission-checkbox')) {
                const { userId, permission } = e.target.dataset;
                const isChecked = e.target.checked;
                try {
                    await updateDoc(doc(db, AppState.membersPath, userId), { [`permissions.${permission}`]: isChecked });
                    showToast('Permissions updated.', 'success');
                } catch (error) {
                    console.error("Error updating permissions:", error);
                    showToast("Failed to update permissions.", "error");
                    e.target.checked = !isChecked; 
                }
            }
        });

        refreshUserRolesBtn.addEventListener('click', renderUserRoleManagement);

        refreshDriversBtn.addEventListener('click', renderDriversList);

        driversListEl.addEventListener('click', (e) => {
            const removeBtn = e.target.closest('.remove-driver-btn');
            if (removeBtn && checkPermission('canManageDrivers')) {
                const driverId = removeBtn.dataset.driverId;
                showConfirmModal('Remove Driver?', 'This will remove the driver from the active list. They will reappear if they send a new location update.', () => {
                    deleteDoc(doc(db, AppState.driversPath, driverId))
                        .then(() => showToast('Driver removed from active list.', 'success'))
                        .catch(err => {
                            console.error("Error removing driver:", err);
                            showToast("Failed to remove driver.", "error");
                        });
                });
            }
        });

        function listenForJobMessages(jobId) {
            if (AppState.currentJobChatUnsubscribe) AppState.currentJobChatUnsubscribe();
            const messagesRef = collection(db, AppState.jobsPath, jobId, 'messages');
            AppState.currentJobChatUnsubscribe = onSnapshot(query(messagesRef), (snapshot) => {
                jobChatBox.innerHTML = '';
                const messages = snapshot.docs.map(d => d.data()).sort((a,b) => a.timestamp - b.timestamp);
                messages.forEach(msg => {
                    const msgEl = document.createElement('div');
                    const isMe = msg.senderId === AppState.currentUser.id;
                    msgEl.className = `chat-message flex ${isMe ? 'justify-end' : 'justify-start'} mb-2`;
                    const timestamp = msg.timestamp ? msg.timestamp.toDate().toLocaleString() : 'sending...';
                    msgEl.innerHTML = `<div class="rounded-lg px-3 py-2 ${isMe ? 'bg-blue-600 text-white' : 'bg-gray-700 text-gray-200'}">
                        <div class="flex justify-between items-center">
                           <p class="text-sm font-bold">${msg.senderName}</p>
                           <p class="text-xs ${isMe ? 'text-blue-200' : 'text-gray-400'} ml-3">${timestamp}</p>
                        </div>
                        <p class="text-sm mt-1">${msg.text}</p>
                    </div>`;
                    jobChatBox.appendChild(msgEl);
                });
                jobChatBox.scrollTop = jobChatBox.scrollHeight;
            }, (err) => console.error(`Error listening for messages on job ${jobId}:`, err));
        }

        jobChatForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            const jobId = jobChatForm.dataset.jobId;
            const text = jobChatInput.value.trim();
            if (!text || !jobId) return;

            try {
                await addDoc(collection(db, AppState.jobsPath, jobId, 'messages'), {
                    text,
                    senderId: AppState.currentUser.id,
                    senderName: AppState.currentUser.name,
                    timestamp: serverTimestamp()
                });
                jobChatInput.value = '';

                try {
                    const jobRef = doc(db, AppState.jobsPath, jobId);
                    await updateDoc(jobRef, { lastMessageTimestamp: serverTimestamp() });
                } catch (timestampError) {
                    console.log('Could not update message timestamp, likely due to permissions:', timestampError.message);
                }

            } catch (error) {
                console.error("Error sending message:", error);
                showToast("Could not send message.", "error");
            }
        });

        // --- Company Logic ---
        async function openCompanyModal() {
            try {
                createCompanyForm.reset(); 
                const companiesRef = collection(db, AppState.companiesPath);
                const snapshot = await getDocs(query(companiesRef));
                companyListEl.innerHTML = '';
                if (snapshot.empty) {
                    companyListEl.innerHTML = `<li class="text-gray-400">No companies found. Create one to get started.</li>`;
                } else {
                    snapshot.forEach(doc => {
                        const company = { id: doc.id, ...doc.data() };
                        const li = document.createElement('li');
                        li.className = 'flex justify-between items-center bg-gray-700 p-3 rounded-md';
                        li.innerHTML = `
                            <span class="font-semibold text-white">${company.name}</span>
                            <button data-company-id="${company.id}" data-has-password="${!!company.hasPassword}" class="join-company-btn px-3 py-1 bg-blue-600 text-white text-sm rounded hover:bg-blue-700">Join</button>
                        `;
                        companyListEl.appendChild(li);
                    });
                }
                companyModal.classList.remove('hidden');
            } catch (error) {
                console.error("Error fetching companies:", error);
                showToast("Could not load company list.", "error");
            }
        }

        async function joinCompany(companyId, password = null) {
            const button = document.querySelector(`.join-company-btn[data-company-id="${companyId}"]`);
            if(button) button.innerHTML = `<span class="spinner"></span>`;

            try {
                const companyRef = doc(db, AppState.companiesPath, companyId);
                const companyDoc = await getDoc(companyRef);
                if (!companyDoc.exists()) {
                    showToast("Company not found.", "error");
                    if(button) button.textContent = 'Join';
                    return;
                }
                const companyData = companyDoc.data();

                if (companyData.hasPassword && companyData.password !== password) {
                    showToast("Incorrect password.", "error");
                    if(button) button.textContent = 'Join';
                    return;
                }
                
                const memberRef = doc(db, `${AppState.companiesPath}/${companyId}/members`, AppState.currentUser.id);
                await setDoc(memberRef, {
                    name: AppState.currentUser.name,
                    email: AppState.currentUser.email,
                    permissions: { 
                        canCreateJob: false,
                        canDeleteJob: false,
                        canManageDrivers: false
                    }
                });

                const userRef = doc(db, AppState.globalUsersPath, AppState.currentUser.id);
                await updateDoc(userRef, { currentCompanyId: companyId });

                showToast(`Successfully joined ${companyData.name}!`, 'success');
                companyModal.classList.add('hidden');
                companyPasswordModal.classList.add('hidden');
            } catch (error) {
                console.error("Error joining company:", error);
                showToast("Failed to join company.", "error");
                if(button) button.textContent = 'Join';
            }
        }

        createCompanyForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            const name = newCompanyNameInput.value.trim();
            const password = newCompanyPasswordInput.value.trim();
            if (!name) return;

            try {
                const newCompanyRef = doc(collection(db, AppState.companiesPath));
                await setDoc(newCompanyRef, {
                    name: name,
                    hasPassword: !!password,
                    password: password || null, 
                    ownerId: AppState.currentUser.id
                });

                const ownerMemberRef = doc(db, `${AppState.companiesPath}/${newCompanyRef.id}/members`, AppState.currentUser.id);
                await setDoc(ownerMemberRef, {
                    name: AppState.currentUser.name,
                    email: AppState.currentUser.email,
                    permissions: {
                        canCreateJob: true,
                        canDeleteJob: true,
                        canManageDrivers: true
                    }
                });
                
                const userRef = doc(db, AppState.globalUsersPath, AppState.currentUser.id);
                await updateDoc(userRef, { currentCompanyId: newCompanyRef.id });

                createCompanyForm.reset();
            } catch (error) {
                console.error("Error creating company:", error);
                showToast("Failed to create company.", "error");
            }
        });
        
        selectCompanyBtn.addEventListener('click', openCompanyModal);
        companyCancelBtn.addEventListener('click', () => {
            if (!AppState.companyId) {
                showToast("You must select or create a company to use the app.", "error");
            } else {
                companyModal.classList.add('hidden');
            }
        });
        companyPasswordCancelBtn.addEventListener('click', () => companyPasswordModal.classList.add('hidden'));

        companyListEl.addEventListener('click', (e) => {
            if (e.target.classList.contains('join-company-btn')) {
                const { companyId, hasPassword } = e.target.dataset;
                if (hasPassword === 'true') {
                    AppState.passwordJoinCompanyId = companyId;
                    companyPasswordTitle.textContent = `Enter Password for ${e.target.previousElementSibling.textContent}`;
                    companyPasswordModal.classList.remove('hidden');
                } else {
                    joinCompany(companyId);
                }
            }
        });

        companyPasswordForm.addEventListener('submit', (e) => {
            e.preventDefault();
            const password = companyPasswordInput.value;
            joinCompany(AppState.passwordJoinCompanyId, password);
            companyPasswordForm.reset();
        });


        // Modal Close Buttons
        openUserGuideBtn.addEventListener('click', () => userGuideModal.classList.remove('hidden'));
        userGuideCloseBtn.addEventListener('click', () => userGuideModal.classList.add('hidden'));
        
        openInviteModalBtn.addEventListener('click', () => {
            if (!AppState.companyId) {
                showToast("Please select a company before inviting others.", "error");
                return;
            }
            settingsModal.classList.add('hidden');
            const baseUrl = window.location.href.split('?')[0];
            const url = `${baseUrl}?companyId=${AppState.companyId}`;
            shareLinkInput.value = url;
            qrcodeEl.innerHTML = '';
            new QRCode(qrcodeEl, {
                text: url,
                width: 128,
                height: 128,
            });
            inviteModal.classList.remove('hidden');
        });
        inviteCancelBtn.addEventListener('click', () => inviteModal.classList.add('hidden'));

        copyLinkBtn.addEventListener('click', () => {
            shareLinkInput.select();
            document.execCommand('copy');
            showToast('Link copied to clipboard!', 'success');
        });

        emailInviteForm.addEventListener('submit', (e) => {
            e.preventDefault();
            const email = emailInviteInput.value;
            const subject = `Invitation to join ${AppState.companyName} on Route Tracker`;
            const body = `You've been invited to join ${AppState.companyName} on Route Tracker. Click this link to get started: ${shareLinkInput.value}`;
            window.location.href = `mailto:${email}?subject=${encodeURIComponent(subject)}&body=${encodeURIComponent(body)}`;
            emailInviteInput.value = '';
        });

        commentForm.addEventListener('submit', (e) => {
            e.preventDefault();
            const comment = commentInput.value.trim();
            const file = podUploadInput.files[0];
            if (comment && typeof AppState.commentCallback === 'function') {
                AppState.commentCallback(comment, file);
            }
            commentModal.classList.add('hidden');
            AppState.commentCallback = null;
        });
        commentCancelBtn.addEventListener('click', () => {
            commentModal.classList.add('hidden');
            AppState.commentCallback = null;
        });
        profileCancelBtn.addEventListener('click', () => profileModal.classList.add('hidden'));
        settingsCancelBtn.addEventListener('click', () => settingsModal.classList.add('hidden'));
        adminSettingsCancelBtn.addEventListener('click', () => adminSettingsModal.classList.add('hidden'));
        createJobCancelBtn.addEventListener('click', () => createJobModal.classList.add('hidden'));
        
        jobDetailsCloseBtn.addEventListener('click', closeJobDetailsModal);
        
        jobDetailsModal.addEventListener('click', (e) => {
            const button = e.target.closest('button');
            if (!button) return;

            const { jobId } = button.dataset;

            if (button.id === 'job-details-accept-btn') {
                showConfirmModal('Accept Job?', 'Are you sure you want to accept this job?', async () => {
                    await acceptJob(jobId);
                    closeJobDetailsModal();
                });
            } else if (button.id === 'job-details-driver-cancel-btn') {
                showConfirmModal('Cancel Assignment?', 'Are you sure you want to remove yourself from this job?', () => cancelAcceptedJob(jobId));
            } else if (button.id === 'edit-job-btn') {
                const job = AppState.allJobs.find(j => j.id === jobId);
                if (job) {
                    closeJobDetailsModal();
                    openCreateJobModal(job);
                }
            } else if (button.id === 'archive-job-btn') {
                archiveJob(jobId);
            } else if (button.id === 'unarchive-job-modal-btn') {
                unarchiveJob(jobId);
            } else if (button.id === 'delete-job-btn') {
                showConfirmModal('Delete Job?', 'This action is permanent and cannot be undone.', () => deleteJob(jobId));
            } else if (button.id === 'print-job-btn') {
                window.print();
            // FINALIZE JOB FIX: Add event handler for the new button
            } else if (button.id === 'finalize-job-btn') {
                const jobId = button.dataset.jobId;
                showCommentModal('Add Closing Comment & Finalize', (comment) => {
                    closeOutJob(jobId, comment);
                    closeJobDetailsModal();
                });
            } else if (e.target === jobDetailsModal) {
                closeJobDetailsModal();
            }
        });

        confirmCancelBtn.addEventListener('click', () => {
            confirmModal.classList.add('hidden');
            AppState.confirmCallback = null;
        });
        confirmActionBtn.addEventListener('click', () => {
            if (typeof AppState.confirmCallback === 'function') AppState.confirmCallback();
            confirmModal.classList.add('hidden');
            AppState.confirmCallback = null;
        });

        function addDestinationInput(value = '') {
            const destinationCount = destinationsContainer.children.length;
            const newDestDiv = document.createElement('div');
            newDestDiv.className = 'flex items-center space-x-2';

            const input = document.createElement('input');
            input.type = 'text';
            input.className = 'w-full px-4 py-2 bg-gray-700 border border-gray-600 rounded-lg text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-blue-500';
            input.placeholder = `Destination ${destinationCount + 1}`;
            if (value) {
                input.value = value;
            }

            // Initialize Autocomplete
            new google.maps.places.Autocomplete(input);

            const removeBtn = document.createElement('button');
            removeBtn.type = 'button';
            removeBtn.className = `remove-destination-btn p-1 text-red-400 hover:text-red-300 ${destinationCount === 0 ? 'hidden' : ''}`;
            removeBtn.innerHTML = `<svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12H9m12 0a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>`;

            newDestDiv.appendChild(input);
            newDestDiv.appendChild(removeBtn);
            destinationsContainer.appendChild(newDestDiv);

            removeBtn.addEventListener('click', () => {
                newDestDiv.remove();
                Array.from(destinationsContainer.children).forEach((child, index) => {
                    const inp = child.querySelector('input');
                    if(inp) inp.placeholder = `Destination ${index + 1}`;
                });
                 optimizeRouteContainer.classList.toggle('hidden', destinationsContainer.children.length <= 1);
            });
             optimizeRouteContainer.classList.toggle('hidden', destinationsContainer.children.length <= 1);
        }

        addDestinationBtn.addEventListener('click', () => addDestinationInput());
        
        function setupTrackingLinkModal(job) {
            AppState.currentJobIdForModal = job.id;
            trackingLinkMobileInput.value = job.thirdPartyMobile || job.contactNumber || '';

            if (job.thirdPartyInviteId) {
                const baseUrl = window.location.href.split('?')[0];
                const url = `${baseUrl}?jobId=${job.id}&inviteId=${job.thirdPartyInviteId}`;
                trackingLinkUrlInput.value = url;
                trackingLinkQrcodeEl.innerHTML = '';
                new QRCode(trackingLinkQrcodeEl, { text: url, width: 128, height: 128 });
                trackingLinkForm.classList.add('hidden');
                trackingLinkDetails.classList.remove('hidden');
            } else {
                trackingLinkForm.classList.remove('hidden');
                trackingLinkDetails.classList.add('hidden');
            }
            trackingLinkModal.classList.remove('hidden');
        }

        trackingLinkContainer.addEventListener('click', (e) => {
            const jobId = e.target.dataset.jobId;
            if (!jobId) return;
            const job = AppState.allJobs.find(j => j.id === jobId);
            if (job) {
                setupTrackingLinkModal(job);
            }
        });

        trackingLinkForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            const jobId = AppState.currentJobIdForModal;
            if (!jobId) {
                showToast("No job selected.", "error");
                return;
            }

            const jobData = AppState.allJobs.find(j => j.id === jobId);
            if (!jobData) {
                showToast("Job data not found.", "error");
                return;
            }

            const inviteId = crypto.randomUUID();
            const jobRef = doc(db, AppState.jobsPath, jobId);
            const publicJobRef = doc(db, AppState.publicJobsPath, jobId);
            const expiresAt = Timestamp.fromDate(new Date(Date.now() + 12 * 60 * 60 * 1000));

            try {
                const batch = writeBatch(db);
                batch.update(jobRef, { 
                    thirdPartyInviteId: inviteId,
                    log: arrayUnion({ text: `Tracking link created by ${AppState.currentUser.name}`, timestamp: new Date() })
                });
                batch.set(publicJobRef, {
                    jobName: jobData.jobName,
                    origin: jobData.origin,
                    destinations: jobData.destinations,
                    driverLocation: null,
                    status: jobData.status,
                    jobDate: jobData.jobDate,
                    totalDistance: jobData.totalDistance,
                    totalDuration: jobData.totalDuration,
                    thirdPartyInviteId: inviteId,
                    expiresAt: expiresAt
                });
                await batch.commit();

                showToast("Tracking link generated!", "success");
                
                const updatedJobData = { ...jobData, thirdPartyInviteId: inviteId };
                const jobIndex = AppState.allJobs.findIndex(j => j.id === jobId);
                if (jobIndex > -1) {
                    AppState.allJobs[jobIndex] = updatedJobData;
                }
                
                setupTrackingLinkModal(updatedJobData);
                
                const buttonInDetails = document.querySelector(`#tracking-link-container button[data-job-id="${jobId}"]`);
                if(buttonInDetails) {
                    buttonInDetails.textContent = 'View Tracking Link';
                    buttonInDetails.id = 'view-tracking-link-btn';
                }

            } catch (error) {
                console.error("Error generating tracking link:", error);
                showToast("Failed to generate tracking link.", "error");
            }
        });

        sendSmsBtn.addEventListener('click', async () => {
            const mobile = trackingLinkMobileInput.value.trim();
            const url = trackingLinkUrlInput.value;
            const jobId = AppState.currentJobIdForModal;

            if (!mobile || !url || !jobId) {
                showToast("Mobile number and link are required.", "error");
                return;
            }
            
            console.log(`Simulating SMS to ${mobile} with link: ${url}`);
            showToast(`Simulated SMS sent to ${mobile}`, 'success');

            try {
                const jobRef = doc(db, AppState.jobsPath, jobId);
                await updateDoc(jobRef, { thirdPartyMobile: mobile });
            } catch (error) {
                console.error("Failed to update mobile number on job:", error);
            }
        });

        copyTrackingLinkBtn.addEventListener('click', () => {
            trackingLinkUrlInput.select();
            document.execCommand('copy');
            showToast('Tracking link copied!', 'success');
        });

        trackingLinkCloseBtn.addEventListener('click', () => {
            trackingLinkModal.classList.add('hidden');
        });

        // --- Driver Location Sharing ---
        shareLocationBtn.addEventListener('click', async () => {
            const driverId = AppState.currentUser.id;
            const publicDriverRef = doc(db, AppState.publicDriversPath, driverId);
            
            try {
                const docSnap = await getDoc(publicDriverRef);
                let shareToken;
                let publicData = {};

                if (docSnap.exists()) {
                    publicData = docSnap.data();
                    shareToken = publicData.shareToken;
                }
                
                if (!shareToken) {
                    shareToken = crypto.randomUUID();
                    const expiresAt = Timestamp.fromDate(new Date(Date.now() + 12 * 60 * 60 * 1000));
                    await setDoc(publicDriverRef, {
                        name: AppState.currentUser.name,
                        phone: AppState.currentUser.phone,
                        shareToken: shareToken,
                        timestamp: serverTimestamp(),
                        expiresAt: expiresAt
                    }, { merge: true });
                }

                const baseUrl = window.location.href.split('?')[0];
                const url = `${baseUrl}?driverId=${driverId}&inviteId=${shareToken}`;
                
                locationShareUrlInput.value = url;
                locationShareMobileInput.value = AppState.currentUser.phone || '';
                locationShareQrcodeEl.innerHTML = '';
                new QRCode(locationShareQrcodeEl, { text: url, width: 128, height: 128 });

                if (publicData.destination) {
                    locationShareDestinationInput.value = publicData.destination;
                    personalRouteEta.textContent = publicData.eta || '--';
                    personalRouteDistance.textContent = publicData.distance || '--';
                    personalRouteInfo.classList.remove('hidden');
                    setPersonalRouteBtn.classList.add('hidden');
                    clearPersonalRouteBtn.classList.remove('hidden');
                } else {
                    locationShareDestinationInput.value = '';
                    personalRouteInfo.classList.add('hidden');
                    setPersonalRouteBtn.classList.remove('hidden');
                    clearPersonalRouteBtn.classList.add('hidden');
                }

                locationShareModal.classList.remove('hidden');

            } catch (error) {
                console.error("Error creating shareable location link:", error);
                showToast("Could not create sharing link.", "error");
            }
        });

        setPersonalRouteBtn.addEventListener('click', () => {
            const destination = locationShareDestinationInput.value.trim();
            if (!destination) {
                showToast("Please enter a destination.", "error");
                return;
            }

            const driver = AppState.activeDrivers.find(d => d.id === AppState.currentUser.id);
            if (!driver || !driver.location) {
                showToast("Your current location is not available yet. Please wait a moment.", "error");
                return;
            }

            const origin = { lat: driver.location.latitude, lng: driver.location.longitude };

            AppState.directionsService.route({
                origin: origin,
                destination: destination,
                travelMode: routesLibrary.TravelMode.DRIVING
            }, async (response, status) => {
                if (status === 'OK') {
                    const leg = response.routes[0].legs[0];
                    const publicDriverRef = doc(db, AppState.publicDriversPath, AppState.currentUser.id);
                    try {
                        await updateDoc(publicDriverRef, {
                            destination: destination,
                            eta: leg.duration.text,
                            distance: leg.distance.text
                        });
                        personalRouteEta.textContent = leg.duration.text;
                        personalRouteDistance.textContent = leg.distance.text;
                        personalRouteInfo.classList.remove('hidden');
                        setPersonalRouteBtn.classList.add('hidden');
                        clearPersonalRouteBtn.classList.remove('hidden');
                        showToast("Personal route set!", "success");
                    } catch (error) {
                        console.error("Error setting personal route:", error);
                        showToast("Could not set personal route.", "error");
                    }
                } else {
                    showToast("Could not calculate route to destination.", "error");
                }
            });
        });

        clearPersonalRouteBtn.addEventListener('click', async () => {
            const publicDriverRef = doc(db, AppState.publicDriversPath, AppState.currentUser.id);
            try {
                await updateDoc(publicDriverRef, {
                    destination: null,
                    eta: null,
                    distance: null
                });
                locationShareDestinationInput.value = '';
                personalRouteInfo.classList.add('hidden');
                setPersonalRouteBtn.classList.remove('hidden');
                clearPersonalRouteBtn.classList.add('hidden');
                showToast("Personal route cleared.", "success");
            } catch (error) {
                console.error("Error clearing personal route:", error);
                showToast("Could not clear personal route.", "error");
            }
        });

        sendLocationSmsBtn.addEventListener('click', () => {
            const mobile = locationShareMobileInput.value.trim();
            const url = locationShareUrlInput.value;
            if (!mobile || !url) {
                showToast("Mobile number and link are required.", "error");
                return;
            }
            console.log(`Simulating SMS to ${mobile} with link: ${url}`);
            showToast(`Simulated SMS sent to ${mobile}`, 'success');
        });

        copyLocationShareBtn.addEventListener('click', () => {
            locationShareUrlInput.select();
            document.execCommand('copy');
            showToast('Link copied!', 'success');
        });

        locationShareCloseBtn.addEventListener('click', () => {
            locationShareModal.classList.add('hidden');
        });

        createGeofenceBtn.addEventListener('click', () => {
            if (!AppState.drawingManager) {
                AppState.drawingManager = new drawingLibrary.DrawingManager({
                    drawingMode: mapsLibrary.drawing.OverlayType.POLYGON,
                    drawingControl: true,
                    drawingControlOptions: {
                        position: coreLibrary.ControlPosition.TOP_CENTER,
                        drawingModes: [mapsLibrary.drawing.OverlayType.POLYGON],
                    },
                });

                coreLibrary.event.addListener(AppState.drawingManager, 'overlaycomplete', (event) => {
                    if (AppState.currentPolygon) {
                        AppState.currentPolygon.setMap(null);
                    }
                    AppState.currentPolygon = event.overlay;
                    AppState.drawingManager.setDrawingMode(null); // Exit drawing mode
                    geofenceModal.classList.remove('hidden'); // Show modal to name and save
                });
            }
            AppState.drawingManager.setMap(AppState.map);
        });

        geofenceSaveBtn.addEventListener('click', async () => {
            const name = geofenceNameInput.value.trim();
            if (!name) {
                showToast("Please enter a name for the geofence.", "error");
                return;
            }
            if (!AppState.currentPolygon) {
                showToast("Please draw a geofence on the map first.", "error");
                return;
            }

            const path = AppState.currentPolygon.getPath().getArray().map(p => ({ lat: p.lat(), lng: p.lng() }));

            try {
                await addDoc(collection(db, `${AppState.companiesPath}/${AppState.companyId}/geofences`), {
                    name: name,
                    path: path,
                    createdAt: serverTimestamp()
                });
                showToast("Geofence saved successfully!", "success");
                geofenceModal.classList.add('hidden');
                geofenceNameInput.value = '';
                if (AppState.currentPolygon) {
                    AppState.currentPolygon.setMap(null);
                    AppState.currentPolygon = null;
                }
                if (AppState.drawingManager) {
                    AppState.drawingManager.setMap(null);
                }
            } catch (error) {
                console.error("Error saving geofence:", error);
                showToast("Failed to save geofence.", "error");
            }
        });

        walkingModeBtn.addEventListener('click', () => {
            const isWalkingMode = trailCreationPanel.classList.toggle('hidden');
            savedTrailsPanel.classList.toggle('hidden', isWalkingMode);
            geofencePanel.classList.toggle('hidden', !isWalkingMode);
            jobDashboardPanel.classList.toggle('hidden', !isWalkingMode);
            driversPanel.classList.toggle('hidden', !isWalkingMode);

            if (!isWalkingMode) {
                AppState.map.setMapTypeId('terrain');
                walkingModeBtn.textContent = 'Exit Walking Mode';
                walkingModeBtn.classList.remove('bg-purple-600', 'hover:bg-purple-700');
                walkingModeBtn.classList.add('bg-gray-600', 'hover:bg-gray-700');
            } else {
                AppState.map.setMapTypeId('roadmap');
                walkingModeBtn.textContent = 'Walking Mode';
                walkingModeBtn.classList.add('bg-purple-600', 'hover:bg-purple-700');
                walkingModeBtn.classList.remove('bg-gray-600', 'hover:bg-gray-700');
            }
        });

        startRecordingBtn.addEventListener('click', () => {
            AppState.isRecording = true;
            AppState.currentTrail = new mapsLibrary.Polyline({
                map: AppState.map,
                strokeColor: '#FF0000',
                strokeOpacity: 1.0,
                strokeWeight: 3
            });
            startRecordingBtn.classList.add('hidden');
            dropPointBtn.classList.remove('hidden');
            autoRecordContainer.classList.remove('hidden');
            finishSaveBtn.classList.remove('hidden');
            trailNavigationContainer.classList.add('hidden');
        });

        dropPointBtn.addEventListener('click', () => {
            if (AppState.userMarker) {
                const path = AppState.currentTrail.getPath();
                path.push(AppState.userMarker.getPosition());
            }
        });

        autoRecordSwitch.addEventListener('change', (e) => {
            if (e.target.checked) {
                AppState.lastRecordedPosition = AppState.userMarker ? AppState.userMarker.getPosition() : null;
            } else {
                AppState.lastRecordedPosition = null;
            }
        });

        finishSaveBtn.addEventListener('click', () => {
            trailModal.classList.remove('hidden');
        });

        trailSaveBtn.addEventListener('click', async () => {
            const name = trailNameInput.value.trim();
            const saveAsGeofence = document.getElementById('save-trail-as-geofence-switch').checked;

            if (!name) {
                showToast("Please enter a name for the trail.", "error");
                return;
            }
            if (!AppState.currentTrail) {
                showToast("No trail to save.", "error");
                return;
            }

            const path = AppState.currentTrail.getPath().getArray().map(p => ({ lat: p.lat(), lng: p.lng() }));

            try {
                if (saveAsGeofence) {
                    await addDoc(collection(db, `${AppState.companiesPath}/${AppState.companyId}/geofences`), {
                        name: name,
                        path: path,
                        createdAt: serverTimestamp()
                    });
                    showToast("Geofence saved successfully!", "success");
                } else {
                    await addDoc(collection(db, `${AppState.companiesPath}/${AppState.companyId}/trails`), {
                        name: name,
                        path: path,
                        createdAt: serverTimestamp()
                    });
                    showToast("Trail saved successfully!", "success");
                }
                trailModal.classList.add('hidden');
                trailNameInput.value = '';
                if (AppState.currentTrail) {
                    AppState.currentTrail.setMap(null);
                    AppState.currentTrail = null;
                }
                AppState.isRecording = false;
                startRecordingBtn.classList.remove('hidden');
                dropPointBtn.classList.add('hidden');
                autoRecordContainer.classList.add('hidden');
                finishSaveBtn.classList.add('hidden');
            } catch (error) {
                console.error("Error saving trail:", error);
                showToast("Failed to save trail.", "error");
            }
        });

        trailCancelBtn.addEventListener('click', () => {
            trailModal.classList.add('hidden');
        });

        geofenceCancelBtn.addEventListener('click', () => {
            geofenceModal.classList.add('hidden');
            if (AppState.currentPolygon) {
                AppState.currentPolygon.setMap(null);
                AppState.currentPolygon = null;
            }
            if (AppState.drawingManager) {
                AppState.drawingManager.setMap(null);
            }
        });


        // --- Offline Handling ---
        window.addEventListener('online', () => {
            offlineBanner.classList.add('hidden');
            showToast('You are back online.', 'success');
        });
        window.addEventListener('offline', () => {
            offlineBanner.classList.remove('hidden');
        });

        async function startApp() {
            loadingOverlay.classList.remove('hidden');
            const firebaseReady = await initializeFirebase();
            if (!firebaseReady) {
                loadingOverlay.classList.add('hidden');
                settingsModal.classList.remove('hidden');
                return;
            }

            const urlParams = new URLSearchParams(window.location.search);
            const publicJobId = urlParams.get('jobId');
            const publicDriverId = urlParams.get('driverId');
            const inviteId = urlParams.get('inviteId');

            if (publicJobId && inviteId) {
                await loadPublicJobView(publicJobId, inviteId);
            } else if (publicDriverId && inviteId) {
                await loadPublicDriverView(publicDriverId, inviteId);
            } else {
                await loadGoogleMapsScript();
                startRegularAuthFlow();
            }
        }

        window.onload = () => {
            startApp();
        };

    </script>
    
</body>
</html>



